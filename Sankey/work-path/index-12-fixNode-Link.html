<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Darya-Yarparvar__Graphic Designer</title>
		<meta name="description" content="Darya Yarparvar * Graphic Designer * Birmingham, UK * Open to work! ** Please visit my personal website and view my works. ** I would be more than happy to be of any help to your creative projects! **">
		<meta name="author" content="Â© 2021 Darya Yarparvar. All rights reserved.">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

		<link rel="preconnect" href="https://use.typekit.net/mok3rgv.css">
		
		
		<link rel="stylesheet" type="text/css" href="css/style.css">


		<link rel="stylesheet" type="text/css" href="css/icon-style.css">
		<link rel="stylesheet" href="https://use.typekit.net/mok3rgv.css">


		<base target="_blank">



        <script type="text/javascript" src="js/d3.js"></script>
        <script type="text/javascript" src="js/d3-sankey.js"></script>
       	
	</head>
	<body>
		
		
		<div id="wrapper">
			<div id="container" class="grid">
				
				<div id="context">
					<h1 id="heading">Scrabble Strings</h1>
					<h3 id="intro"> I wanted to practice Sankey diagram. I am fascinated by words. and could not help myself not choose a playful subject! so here it is, ladys and gentelman! you & scrabble sankey! play and have fun!</h3>
					<p>Words are strings of letters. Each node represents a letter at a specific position.</p>
				</div>
					
				<div id="userGuide">
					<h2>How to use & read the chart</h2>	
					<p>First, set the upper limit for words' length (the default is set to the longest word in the dataset). Click on a node to narrow down the word list to those words that have the selected letter at the selected position. </p>
				</div>
					
				
				<!-- <div id="legend">
						<h3>How to read the chart</h3>	
				</div> -->



				<div id="slider">
				  	<label for="wordLength">Set the word length limit</label>
					<input type="range" min="1" max="31" value="10" id="wordLength">
				</div>


				<div id="reset">
					<a class="button">Reset to the whole dataset</a>
				</div>

			  	<div id="list">
					<a href="" download="selected-word-list.txt" class="button">Download the word list</a>
				</div>


				<div id="graphics">

				</div>


				<div id="file">
				  	<label for="dataFile">You can upload your own word list [in .txt format] & play with the diagram! </label>
					<input type="file" name="loadData" id="dataFile">
				</div>


				<div id="footnotes">
						<h2>footnotes & methods</h2>	
				</div>



					
			</div>
				


				
				
				




				



			</div>
			
			
		</div>

<!--
*****************************
****************************
***************************
************************** Data Visualisation Code __ START 
***************************
****************************
******************************
-->


		<script type="text/javascript">
			
// Settings (Width and height) from outside to inside

			

			var width = screen.availWidth,
				height = screen.availHeight,

				padding = {top: 60, right: 60, bottom: 60, left: 60},
				margin = {top: 20, right: 20, bottom: 30, left: 40};

			

// Load in raw data & THEN...
			d3.json("data/words_dictionary-test.json").then(function(rawdata) {  //I deleted "jean-christophe": 1, from data. due to - character.
				// console.log(rawdata); //OK

				const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
				const vowels = ["a","e","i","o","u"];
				const consonents = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"];

	//Read data
				var mainWords = Object.keys(rawdata);
				console.log("mainWords", mainWords); //OK	

	//Data & Funcitons

			

				var sankeyHeight = 500; //height*1.2;

				
				// the length of the longest word	
				// L = d3.max(mainWords, w => w.length);   //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length) in this part : words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));, then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				// console.log("max word length", L); //OK
				

				
				// Slider
				// set slider intial value to max length of the whole dataset
				d3.select("#wordLength")
					.node()
					.setAttribute("max", d3.max(mainWords, w => w.length));
				d3.select("#wordLength")
					.node()
					.setAttribute("value", d3.max(mainWords, w => w.length));

				d3.select("#slider")
					.append("span")
					.text(d3.select("#wordLength").node().value);

				// d3.select("#wordLength")
				// 	.node()
				// 	.setAttribute("oninput", "sliderUpdate(this.value)");

				
				


				function prepareData(inputData) {

					console.log("inputData in prepareData scope", inputData); //OK

					
					//the length of the longest word	
					L = d3.max(inputData, w => w.length);
					console.log("max word length", L); //OK
					

					// Nodes
					var nodes = [];
					d3.map(alphabet, letter => { for (let i=1; i<=L; i++) {
													nodes.push({
																name: letter+i,
															});
													}
												});
					console.log("nodes", nodes); //OK

				    // Links
					var links = [];

					var letterByletter = d3.map(inputData, w => Array.from(w));
					d3.map(letterByletter, array => { for (let i=0; i<array.length-1; i++) {
														links.push({
															word : array.join(""),
															source : array[i]+(i+1),
															target : array[(i+1)]+(i+2),
															value : 1,
															});
														}
													});
					console.log("links", links); //OK

					values = d3.rollup(links, g => g.length, obj => obj.source+obj.target);
					console.log("values", values); //OK

					// Data for Sankey
					var data = {
								nodes : nodes.map(d => Object.assign({}, d)),
								links : links.map(d => Object.assign({}, d))
							};
					console.log("data in prepareData scope", data); //OK

					return {data : data,
							L : L} ;
					

				};

				
				
				function highlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 1 : 0.5)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSalmon" : "DarkSeaGreen");
				};

				function unhighlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 0.5 : 0.5)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSeaGreen" : "DarkSeaGreen");
				};


				function highlightNodes(node1,node2) {
				    d3.select(".nodes")
						.selectAll("rect")
						.attr("fill", rect => (rect.index == node1 || rect.index == node2) ? "navy" : "white");
				};






				function filterbyNL(inputData, node, prevFilteredData) {
					nextFilteredData = d3.filter(prevFilteredData, w => (w[(node.depth+1)-1] == node.name.match(/\w/)));
					console.log("prevFilteredData in filter scope", prevFilteredData); //OK
					console.log("nextFilteredData in filter scope", nextFilteredData); //OK
					return nextFilteredData;
				};


				function filterbyLength(inputData, lengthLimit) {
					limitedData = d3.filter(inputData, w => (w.length <= lengthLimit));
					console.log("limitedData in filterbyLength scope", limitedData); //OK
					return limitedData;
				};
			

			// Sankey generator

				function generateSankey(inputData) {   //better to use prepareData inside this function. data still will be available at global scope. and you have control on updating sankey generator based on filtered data.
					
					// console.log("data in generateSankey scope", data); //here data is not defined yet. and so not L.
					data = prepareData(inputData).data;
					L = prepareData(inputData).L; //the first time you are gonna define data. data will be at global scope.
					console.log("data in generateSankey scope", data); // OK.  here data is defined. and so is L :)
					console.log("L in generateSankey scope", L); // OK.  here data is defined. and so is L :)

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodeWidth((((width-margin.left-margin.right)/(L+1))/5))
						      	.nodePadding(0)
						      	// .nodeSort((node1,node2) => d3.ascending(node1.name, node2.name)) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    .linkSort(d3.descending) // it seems without node sorting the results are better!!!! no node crashing ?!?!?!?!?!?!!?!?!!?!?
						      	.extent([[10,10], [width - 10, sankeyHeight - 10]])



						      	// .nodes(nodes.map(d => Object.assign({}, d))) // you can also determine nodes & links of the d3.sankey at this step. or give both of the arguments as data {nodes: , links: } format. like sankey(data). 
						      	// .links(links.map(d => Object.assign({}, d)));
					

					
					sankey(data);

					// fixing the place of a..z nodes at each position (parallel lines with fixed x , width & distance)
					d3.map(data.nodes, node => { 
												distance = (width-margin.left-margin.right)/(L+1);
												nodeWidth = distance/5;

												node.x0 = (node.depth+1)*distance-(nodeWidth/2);
												node.x1 = node.x0+nodeWidth;

												name = node.name.match(/\w/);
												nodeHeight= sankeyHeight/(26+1);
												// console.log(name); //OK
												d3.map(alphabet, letter => (name==letter) ? node.y0 = 10+alphabet.indexOf(letter)*nodeHeight : 1000);
												node.y1 = node.y0 + nodeHeight;
											}
									);

					// fixing the place of links. so all links between two specific nodes are on top of each other. & also each node only encodes the item. and NOT the value. all nodes will have equal length. (fixed y & length)
					d3.map(data.links, link => { 
												link.y0 = (link.source.y0+link.source.y1)/2;
												link.y1 = (link.target.y0+link.target.y1)/2;
											}
									);
				}


				words = filterbyLength(mainWords, d3.max(mainWords, w => w.length)); //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length), then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				generateSankey(words);
				

				

			// Create Chart
				const graphics = d3.select("#graphics");
				const sankeyChart = graphics.append("svg")
										.classed("sankey", true)
										.attr("viewBox", [0, 0, width, sankeyHeight]); //width*1.5
				
				
				function drawSankey(inputData, permission) {

					console.log("data in drawSankey scope", data); //OK
					// data = prepareData(words); //somehow this line causes an error. I could not figure out why!? Maybe because its already defined?!?!
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ; //here if any of nodes has been already clicked the nextFilterData wont be reset to words :) so consecutive clicking will result in step by step filtering and selection of words based on each clicked node & ultimately shrinking the inputData :)

					sankeyChart.append("g")
								.attr("class", "nodes")
						    	.selectAll("rect")
						    	.data(data.nodes)
						    	.join("rect")
						     	.attr("x", d => d.x0)
						      	.attr("y", d => d.y0)
						      	.attr("height", d => (d.y1 - d.y0)) //if svg height is not high enough, y0 & y1 for small values will be equal & rect height = zero. :|
						      	.attr("width", d => (d.x1 - d.x0))
						      	.attr("fill", "white")
						      	.attr("stroke", "navy")
						      	.on("mouseover", function(event, node) {
						      						d3.select(this) //"this" is each <rect>
						      							.attr("fill", "navy")
						      						highlightAdjLinks(node); //node as the second input of a function applied on an event is directly the bind data itself.

										      	})
						      	.on("mouseout", function(event, node){
						      						d3.select(this)
						      							.attr("fill", "white");

						      						// unhighlightAdjLinks(node);
						      									
										      	})
						      	.on("click", function (event, node) {
						      						permissionNode = true; //when permissionNode is true, it means a node has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
													var prevFilteredData = nextFilteredData;
						      						nextFilteredData = filterbyNL(inputData,node,prevFilteredData);
						      						sankeyChart.select(".nodes").remove();
						      						sankeyChart.select(".links").remove();
						      						d3.select(".nodesLabel").remove();

						      						generateSankey(nextFilteredData); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
						      						drawSankey(nextFilteredData, permissionNode); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
						      						
						      						console.log("words on node click", words);
						      						console.log("data on node click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
						      						console.log("prevFilteredData on node click", prevFilteredData); //OK
													console.log("nextFilteredData on node click", nextFilteredData); //OK
						      						highlightAdjLinks(node);

						      						
												      	})
						    	.append("title")
						    	.text(d => `${d.name}\n${d.value}`); // d.name.match((/\w/))

			    	sankeyChart.append("g")
						    	.attr("class", "nodesLabel")
								.selectAll("text")
								.data(data.nodes)
								.join("text")
								.text(d => (d.y0 != d.y1)? `${d.name.match((/\w/))}`: "")  
								.attr("x", d => d.x0+(((width-margin.left-margin.right)/(L+1))/20))
						      	.attr("y", d => d.y0+(d.y1-d.y0)/2)
						   		.attr("font-size", "0.6rem")
						   		.attr("font-weight", "500");

				    sankeyChart.append("g")
							    .attr("class", "links")
							    .attr("fill", "none")
							    .attr("stroke", "DarkSeaGreen")
							    .selectAll("path")
							    .data(data.links)
							    .join("path")
							    .attr("d", d3.sankeyLinkHorizontal())
							    .attr("stroke-width", 1) //if you want to encode link values with width, generally use d => Math.min(1, d.width) or for our case d => values.get(d.source.name+d.target.name) instead of d.width.
							    .attr("stroke-opacity", 0.5)
							    .on("mouseover", function(event, node) { 
													    	d3.select(this)
													    		.attr("stroke", (this.getAttribute("stroke")=="DarkSalmon") ? "red" : "navy")
													    		.attr("stroke-opacity", 1);

													    	index1 = node.source.index;
													    	index2 = node.target.index;	
													    	highlightNodes(index1,index2);
														})
							    .on("mouseout", function(event, node) { 
													    	d3.select(this).attr("stroke", (this.getAttribute("stroke")=="red") ? "DarkSalmon" : "DarkSeaGreen")
													    	.attr("stroke-opacity", (this.getAttribute("stroke")=="DarkSalmon") ? 1 : 0.5);

													    	d3.select(".nodes")
																.selectAll("rect")
																.attr("fill", "white");
													    })
							   .on("click", function(event, node) { 
							    							node1 = node.source;
													    	node2 = node.target;

													    	permissionLink = true; //when permissionLink is true, it means a link has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
															var prevFilteredData = nextFilteredData;
								      						nextFilteredData = Array.from(d3.intersection(filterbyNL(inputData,node1,prevFilteredData),filterbyNL(inputData,node2,prevFilteredData)));  // I had to add Array.from here, comparing to click on node. to have nextFilteredData is an array format. I could not figure out why the results are different when I click on node or link. anyway it's OK now :) even when nextFilteredData is a Set, the code & function works. the only problem is when you want to download the word list. !!!!!!!!!!!!!!!!!!!!
								      						sankeyChart.select(".nodes").remove();
								      						sankeyChart.select(".links").remove();
								      						d3.select(".nodesLabel").remove();

								      						generateSankey(nextFilteredData); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
								      						drawSankey(nextFilteredData, permissionLink); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
								      						
								      						console.log("words on link click", words);
								      						console.log("data on link click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
								      						console.log("prevFilteredData on link click", prevFilteredData); //OK
															console.log("nextFilteredData on link click", nextFilteredData); //OK

															
													    })
								.append("title")
							    .text(d => `${d.source.name} â ${d.target.name}\n${values.get(d.source.name+d.target.name)}`)

				}



				graphics.on("click",  function(event, element) {
											d3.select(".links")
												.selectAll("path")
												.attr("stroke-opacity", 0.5)
												.attr("stroke", "DarkSeaGreen");
										});
							


				
				console.log("data in global scope", data); //OK
				drawSankey(data);


			// // Scale
			// 	lengthXScale = d3.scaleLinear()
			// 						.domain([0, d3.max(summaryCountsCoLength, d => d[0])])
			// 					  	.range([0, width - margin.left])

			// // Axis
			// 	xAxis = g => g
			// 				.classed("xAxis", true)
			// 			    .attr("transform", `translate(${margin.left},${height - margin.bottom })`)
			// 			    .call(d3.axisBottom(lengthXScale).ticks(31).tickSizeOuter(0))
			// 			    .call(g => g.append("text")
			// 					        .attr("x", width - margin.right)
			// 					        .attr("y", -4)
			// 					        .attr("fill", "currentColor")
			// 					        .attr("font-weight", "bold")
			// 					        .attr("text-anchor", "end")
			// 					        .text("word length"));



			// Toolbar

				


				//Slider

				// Slider change
				function sliderUpdate(lengthLimit){

					d3.select("#wordLength")
						.node()
						.setAttribute("value", lengthLimit);

       				// d3.select("#wordLength")
						// .clone();
						
					// d3.select("#wordLength")
					// 	.remove();


					d3.select("#slider")
						.select("span")
						.text(lengthLimit);

					
					sankeyChart.select(".nodes").remove();
					sankeyChart.select(".links").remove();
					d3.select(".nodesLabel").remove();

					words = filterbyLength(mainWords, lengthLimit);
					console.log("words on slider change", words);
					generateSankey(words); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
					drawSankey(words); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
															
		      				
				}


				d3.select("#wordLength")
					.on("click", function() {
											lengthLimit = this.value;
											sliderUpdate(lengthLimit);
										})


				//Buttons

				d3.select("#reset")
					.select(".button")
					.on("click", function() {

										lengthLimit = d3.max(mainWords, w => w.length);
										sliderUpdate(lengthLimit);

										sankeyChart.select(".nodes").remove();
			      						sankeyChart.select(".links").remove();

										words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));
			      						generateSankey(words); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
			      						drawSankey(words, false);
			      						// set slider intial value to max length of the whole dataset
										


									})


				d3.select("#list")
					.select(".button")
					.on("click", function() {
									conent = nextFilteredData;
									header = "data:text/plain;charset=utf-8,"
									payload = header + encodeURIComponent(conent);

									this.href = payload;
								})


				






			  // alert("done");
			});


		</script>
		

	</body>
</html>
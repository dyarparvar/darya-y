<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Darya-Yarparvar__Graphic Designer</title>
		<meta name="description" content="Darya Yarparvar * Graphic Designer * Birmingham, UK * Open to work! ** Please visit my personal website and view my works. ** I would be more than happy to be of any help to your creative projects! **">
		<meta name="author" content="Â© 2021 Darya Yarparvar. All rights reserved.">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

		<link rel="preconnect" href="https://use.typekit.net/mok3rgv.css">
		
		
		<link rel="stylesheet" type="text/css" href="css/style.css">


		<link rel="stylesheet" type="text/css" href="css/icon-style.css">
		<link rel="stylesheet" href="https://use.typekit.net/mok3rgv.css">


		<base target="_blank">



        <script type="text/javascript" src="js/d3.js"></script>
        <script type="text/javascript" src="js/d3-sankey.js"></script>
       	
	</head>
	<body>
		
		
		<div id="wrapper">
			<div id="container" class="grid">
				
				<div id="context">
					<h1 id="heading">Scrabble Sankey</h1>
					<h3 id="intro">I could not resist choosing a playful subject to practice Sankey diagram... and I love word games! So here it is: <em>the scrabble sankey</em>! Play with it and have fun!</h3>
					<p><br><br>Words are strings of letters (spread horizontally). Each node represents a letter at a specific position. Each link connects two adjacent letters of a word.<br><br>This Sankey diagram is a multilevel network idiom that combines a node-link diagram with a derived cluster hirearchy, intending the path tracing as the main desired task.</p>
				</div>
					
				<div id="userGuide">
					<h2>How to use this visualisation:</h2>	
					<p>First, set the upper limit for words' length using the slider (the default is set to the longest word in the dataset).<br><br>Click on a node to narrow down the current word list to those words that have the selected letter at the selected position.<br><br>Click on a link to narrow down the current word list to those words that have the selected consecutive letters at those specific positions.<br><br>If you click on the slider without changing its value, the word list filteration caused by clicking node/link will be reset to none.<br><br>You can download the list of the words at whatever step you like :)</p>
				</div>
					
				
				<!-- <div id="legend">
						<h3>How to read the chart</h3>	
				</div> -->



				<div id="slider">
				  	<label for="wordLength">Set the word length limit</label>
					<input type="range" min="1" max="31" value="10" id="wordLength">
				</div>

				<div id="output">
					<h3>How many words?</h3>
					<span></span>
				</div>

				<div id="special">
					<a href="">*</a>
					<a href="">*</a>

				</div>


				<div id="reset">
					<a class="button">Reset</a>
				</div>

			  	<div id="list">
					<a href="" download="selected-word-list.txt" class="button">Download</a>
				</div>


				<div id="graphics" class="grid">

				</div>


				<!-- <div id="file">
				  	<label for="dataFile">You can upload your own word list [in .txt format] & play with the diagram! </label>
					<input type="file" name="loadData" id="dataFile">
				</div> -->


				<div id="footnotes">
						<h2>footnotes & methods</h2>	
				</div>



					
			</div>
				


				
				
				




				



			</div>
			
			
		</div>

<!--
*****************************
****************************
***************************
************************** Data Visualisation Code __ START 
***************************
****************************
******************************
-->


		<script type="text/javascript">
			
/////// Settings (width, height, margin,)

			

			var width = screen.availWidth,
				height = screen.availHeight,

			padding = {top: 60, right: 60, bottom: 60, left: 60},
			margin = {top: 60, right: 50, bottom: 60, left: 50};
			deltaAxis = 40;

			// margin = {top: 150, right: 50, bottom: 100, left: 250}; //trial

			const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
			const vowels = ["a","e","i","o","u"];
			const consonents = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"];


/////// Load & Read data
			
	/////// OPTION 1 : Load in raw JSON data & THEN...
			// d3.json("data/words_dictionary-test.json").then(function(rawdata) {  //I deleted "jean-christophe": 1, from data. due to - character.
			// 	// console.log(rawdata); //OK
			// 	// mainWords = d3.csvParseRows(rawdata, line => line.toString());
				// var mainWords = [...d3.difference(Object.keys(rawdata),alphabet)]; //exclude alphabet because they are single letters & no node/link meaning.
				// console.log("mainWords", mainWords); //OK	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/////// OPTION 2 : Load in raw TEXT data & THEN...
			d3.text("data/list.txt").then(function(rawdata) {
				// console.log(rawdata); //OK
				mainWords = [...d3.difference(d3.csvParseRows(rawdata, line => line.toString().toLowerCase()),alphabet)]; // I deleted "won't" & "don't" 
				console.log("mainWords", mainWords); //OK	 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////// Initiation

				
				// the length of the longest word	
				// L = d3.max(mainWords, w => w.length);   //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length) in this part : words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));, then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				// console.log("max word length", L); //OK
				

				
				// Slider settings
				// set slider intial value to max length of the whole dataset
				d3.select("#wordLength")
					.node()
					.setAttribute("max", d3.max(mainWords, w => w.length));
				d3.select("#wordLength")
					.node()
					.setAttribute("value", d3.max(mainWords, w => w.length));

				d3.select("#slider")
					.append("span")
					.text(d3.select("#wordLength").node().value);

				// Output
				d3.select("#output")
					.select("span")
					.text(mainWords.length);



/////////// Sankey Data Preperation
				function prepareData(inputData) {

					console.log("inputData in prepareData scope", inputData); //OK

					
					//the length of the longest word	
					L = d3.max(inputData, w => w.length);
					console.log("max word length", L); //OK
					

					// Nodes
					var nodes = [];
					d3.map(alphabet, letter => { for (let i=1; i<=L; i++) {
													nodes.push({
																name: letter+i,
															});
													}
												});
					console.log("nodes", nodes); //OK

				    // Links
					var links = [];

					var letterByletter = d3.map(inputData, w => Array.from(w));
					// console.log("letterByletter", letterByletter); //OK
					d3.map(letterByletter, array => { for (let i=0; i<array.length-1; i++) {
														links.push({
															word : array.join(""),
															source : array[i]+(i+1),
															target : array[(i+1)]+(i+2),
															value : 1,
															});
														}
													});
					console.log("links", links); //OK

					values = d3.rollup(links, g => g.length, obj => obj.source+obj.target);
					console.log("values", values); //OK

					// Data for Sankey
					var data = {
								nodes : nodes.map(d => Object.assign({}, d)),
								links : links.map(d => Object.assign({}, d))
							};
					console.log("data in prepareData scope", data); //OK

					return {data : data,
							L : L} ;
				};



/////////// HeatMap Data Preparation
				function infoData(inputData) {
					wordInfo = d3.map(inputData, w => { 
														return {
															word: w,
															key: w[0]+w[w.length-1],
															sameKey: d3.group(inputData, w => w[0]+w[w.length-1]).get(w[0]+w[w.length-1]),
															sameKeyCount: d3.rollup(inputData, g => g.length, w => w[0]+w[w.length-1]).get(w[0]+w[w.length-1]),
															length: w.length,
															sameLength:  d3.group(inputData, w => w.length).get(w.length),
															sameLengthCount:  d3.rollup(inputData, g => g.length, w => w.length).get(w.length)
														};
													});
					
					return wordInfo;
				};
				console.log("heatMapData", infoData(mainWords)); //OK
				
				
				
			

/////////// Interactivity
				function highlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 1 : 0.3)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSalmon" : "DarkSeaGreen");
				};

				function unhighlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 0.3 : 0.3)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSeaGreen" : "DarkSeaGreen");
				};


				function highlightNodes(node1,node2) {
				    d3.select(".nodes")
						.selectAll("rect")
						.attr("fill", rect => (rect.index == node1 || rect.index == node2) ? "navy" : "white");
				};


				function filterbyNL(inputData, node, prevFilteredData) {
					nextFilteredData = d3.filter(prevFilteredData, w => (w[(node.depth+1)-1] == node.name.match(/\w/)));
					console.log("prevFilteredData in filter scope", prevFilteredData); //OK
					console.log("nextFilteredData in filter scope", nextFilteredData); //OK
					return nextFilteredData;
				};


				function filterbyLength(inputData, lengthLimit) {
					limitedData = d3.filter(inputData, w => (w.length <= lengthLimit));
					console.log("limitedData in filterbyLength scope", limitedData); //OK
					return limitedData;
				};


				// Word emerge !
				function wordEmerge(nextFilteredData) {
					if (nextFilteredData.length <= 10) { //or 1.  for 1 condition does not matter actually :)))
						// console.log("null??" , graphics.select(".words").node()); //null OK :)
						// the following condition checks whether a <g> with class ".words" has already been made for emerging words or not. without this condition, for each word, there will be a <g> , which is pointless :))) I want to have all <text> into a single <g> :)
						if (!graphics.select(".words").node()) {  
							graphics.append("g")
									.attr("transform", `translate(${margin.left}, ${margin.top})`)
									.attr("class", "words")
									.selectAll("text")
									.data(nextFilteredData)
									.join("text")
									.text(d=>d)

							} else {
							graphics.select(".words")
									.selectAll("text")
									.data(nextFilteredData)
									.join("text")
									.text(d=>d)
						}
					};
				};

				// words starting with this letter:
				function startLetter(inputData,letter) {
					(!letter) ? letter = w[0] : letter = letter.toString();
					return d3.group(inputData, w => w[0]).get(letter);
				};
				// console.log("words starting with this Letter", startLetter(mainWords, "c")); //OK //for example all the words starting with c.
				
				// words ending with this letter:
				function endLetter(inputData,letter) {
					(!letter) ? letter = w[w.length-1] : letter = letter.toString();
					return d3.group(inputData, w => w[w.length-1]).get(letter);
				};
				// console.log("words ending with this Letter", endLetter(mainWords, "c")); //OK //for example all the words ending with c.
				
				

/////////// Sankey Generator
				var sankeyHeight = 660 - margin.top - margin.bottom - deltaAxis; //height*1.2;
				var sankeyWidth = width - margin.top - margin.bottom;

				function generateSankey(inputData, permission) {   //better to use prepareData inside this function. data still will be available at global scope. and you have control on updating sankey generator based on filtered data.
					
					// console.log("data in generateSankey scope", data); //here data is not defined yet. and so not L.
					data = prepareData(inputData).data;
					L = prepareData(inputData).L; //the first time you are gonna define data. data will be at global scope.
					console.log("data in generateSankey scope", data); // OK.  here data is defined. and so is L :)
					console.log("L in generateSankey scope", L); // OK.  here data is defined. and so is L :)

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodeWidth(((sankeyWidth/(L+1))/5))
						      	.nodePadding(0)
						      	// .nodeSort((node1,node2) => d3.ascending(node1.name, node2.name)) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    .linkSort(d3.descending) // it seems without node sorting the results are better!!!! no node crashing ?!?!?!?!?!?!!?!?!!?!?
						      	.extent([[1,1], [sankeyWidth- 1, sankeyHeight- 1]]);

					sankey(data);

					// filtering out those nodes that has value = 0. 
					realnodes = d3.filter(data.nodes, node => (node.value!=0));
					// sort the nodes first based on the KEY digits (either 2 digits , if null then 1 digit)  & then based on the KEY letter
					realnodes.sort((a,b) => ( (a.name.match(/\d{2}/)|| a.name.match(/\d{1}/)) - (b.name.match(/\d{2}/) || b.name.match(/\d{1}/)) )    ||    (a.name.match(/\w{1}/) - b.name.match(/\w{1}/)) );
					// console.log("realnodes",realnodes); //OK

					// fixing the place of a..z nodes at each position (parallel lines with fixed x , width & distance)
					d3.map(realnodes, node => { 
												distance = sankeyWidth/(L+1);
												nodeWidth = distance/5;

												node.x0 = (node.depth+1)*distance-(nodeWidth/2);
												node.x1 = node.x0+nodeWidth;

												
												// console.log("max nodes at any position?"); //OK
												name = node.name.match(/\w/);
												nodeHeight= sankeyHeight/26;
												// // OPTION 1 : this conditional part of code fixes y0,y1,height of the nodes at overview state. at detail state(click on node/link) the height of nodes encodes their value.
												// if (!permission) {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	node.y1 = node.y0 + nodeHeight;
												// }
												// OPTION 2 : this UNconditional part of code fixes y0,y1,height of the nodes at overview & detail states (click on node/link) & the height of nodes NEVER encodes anything & its always constant.
												{
													d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
													node.y1 = node.y0 + nodeHeight;
												} 
												// OPTION 3 : this condition fixes y0,y1,height of the nodes at detail states (click on node/link) & the height of nodes DO STH!!!!!! ?????!??? 
												// else {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	// node.y1 = node.y0 + nodeHeight;
												// } 
												
											}
									);

					// fixing the place of links. so all links between two specific nodes are on top of each other. & also each node only encodes the item. and NOT the value. all nodes will have equal length. (fixed y & length)
					d3.map(data.links, link => { 
												link.y0 = (link.source.y0+link.source.y1)/2;
												link.y1 = (link.target.y0+link.target.y1)/2;
											}
									);
				};

			
				words = filterbyLength(mainWords, d3.max(mainWords, w => w.length)); //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length), then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				generateSankey(words, false);
			


/////////// Histogram Generator
			  
				function histo(inputData) {
					lengthValues = d3.map(inputData, w => w.length);
					buckets = d3.bin()
								.thresholds(d3.max(inputData, w => w.length));//.thresholds(L) does not gaurantee to recieve L buckets!!! like d3.ticks. 
					// histogram = d3.histogram()
					// 				.thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()); //// you can define your own function .thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()) this example classifies words with respect to their initial letters if the values are inputData=words. 
					// BUT WHY d3.histogram does not work?!?!?!?
					// console.log(buckets.domain()(lengthValues)); //OK by default the domain is the extend of inputData
					return buckets(lengthValues);
				};

				bins = histo(mainWords);
				console.log("bins", bins); //OK


/////////// Contour Generator
				// the contour polygons are GeoJSON
				
				
				// contours = d3.contourDensity()
				// 			    .x(d => x(d.x))
				// 			    .y(d => y(d.y))
				// 			    .size([width, height])
				// 			    .bandwidth(30)
				// 			    .thresholds(30)
				// 			  (data)



/////////// Graphics
				const graphics = d3.select("#graphics");

/////////// Draw Sankey
				const sankeyChart = graphics.append("svg")
										.classed("sankey", true)
										.attr("viewBox", [0, 0, sankeyWidth + margin.left + margin.right , sankeyHeight + margin.top + margin.bottom + deltaAxis]);
				
				
				function drawSankey(inputData, permission) {

					console.log("data in drawSankey scope", data); //OK
					// data = prepareData(words); //somehow this line causes an error. I could not figure out why!? Maybe because its already defined?!?!
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ; //here if any of nodes has been already clicked the nextFilterData wont be reset to words :) so consecutive clicking will result in step by step filtering and selection of words based on each clicked node & ultimately shrinking the inputData :)

					// Nodes
					sankeyChart.append("g")
								.attr("class", "nodes")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
						    	.selectAll("rect")
						    	.data(realnodes) //here since nodes with value=0 has been filtered at generateSankey , instead of using data.nodes, use realnodes & get rid of such a condition at each step of drawing nodes : d => (d.value!=0) ? d.x0 : 100)
						    	.join("rect")
						     	.attr("x", d => d.x0)
						      	.attr("y", d => d.y0)
						      	.attr("height", d => (d.y1 - d.y0))
						      	.attr("width", d => (d.x1 - d.x0))
						      	.attr("fill", "white")
						      	.attr("stroke", "navy")
						      	.on("mouseover", function(event, node) {
										      		nodeData = this.__data__;
						      						d3.select(this) //"this" is each <rect>
						      							.attr("fill", "navy")
						      						d3.select(".nodesLabel")
						      							.append("text")
						      							.attr("class", "temporary")
						      							.text((nodeData.value != 0) ? `${nodeData.name.match(/\w/)}`: "")
						      							.attr("x", (nodeData.x0+nodeData.x1)/2)
												      	.attr("y", (nodeData.y0+nodeData.y1)/2 +2)
												   		.attr("font-size", "10")
												   		.attr("font-weight", "300")
												   		.attr("text-anchor", "middle")
												   		.attr("fill", "DarkSalmon");
						      						highlightAdjLinks(node); //node as the second input of a function applied on an event is directly the bind data itself.

										      	})
						      	.on("mouseout", function(event, node){
						      						d3.select(this)
						      							.attr("fill", "white");

						      						d3.select(".temporary")
														.remove();

						      						// unhighlightAdjLinks(node);
						      									
										      	})
						      	.on("click", function (event, node) {
						      						permissionNode = true; //when permissionNode is true, it means a node has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
													var prevFilteredData = nextFilteredData;
						      						nextFilteredData = filterbyNL(inputData,node,prevFilteredData);
						      						sankeyChart.select(".nodes").remove();
						      						sankeyChart.select(".links").remove();
						      						d3.select(".nodesLabel").remove();
						      						d3.select(".axis").remove();



						      						d3.select("#output")
						      							.select("span")
						      							.text(nextFilteredData.length);

						      						generateSankey(nextFilteredData,permissionNode); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
						      						drawSankey(nextFilteredData, permissionNode); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
						      						
						      						console.log("words on node click", words);
						      						console.log("data on node click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
						      						console.log("prevFilteredData on node click", prevFilteredData); //OK
													console.log("nextFilteredData on node click", nextFilteredData); //OK
						      						highlightAdjLinks(node);

						      						wordEmerge(nextFilteredData);

						      						
												      	})
						    	.append("title")
						    	.text(d => `${d.value}`); // ${d.name}\n${d.value}

					// Node Labels

			    	sankeyChart.append("g")
						    	.attr("class", "nodesLabel")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
								.selectAll("text")
								.data(data.nodes)
								.join("text")
								.text(d => (d.value != 0) ? `${d.name.match((/\w/))}`: "")  
								.attr("x", d => d.x0+((sankeyWidth/(L+1))/10)) // x0 + nodeWidth/2
						      	.attr("y", d => (d.y0+d.y1)/2 +2) // +2 comes from this : lineheight(set equal to 1.2*fontsize at the * {} in style.css) - labelfontsize = 12 - 10 = 2 :)
						   		.attr("font-size", "10")
						   		.attr("font-weight", "300")
						   		.attr("text-anchor", "middle")
						   		.attr("fill", "navy");

					// Links
				    sankeyChart.append("g")
							    .attr("class", "links")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
							    .selectAll("path")
							    .data(data.links)
							    .join("path")
							    .attr("d", d3.sankeyLinkHorizontal())
							    .attr("fill", "none")
							    .attr("stroke", "DarkSeaGreen")
							    .attr("stroke-width", 1) //if you want to encode link values with width, generally use d => Math.min(1, d.width) or for our case d => values.get(d.source.name+d.target.name) instead of d.width.
							    .attr("stroke-opacity", 0.3)
							    .on("mouseover", function(event, node) { 
													    	d3.select(this)
													    		.attr("stroke", (this.getAttribute("stroke")=="DarkSalmon") ? "Tomato" : "navy")
													    		.attr("stroke-opacity", 1);

													    	index1 = node.source.index;
													    	index2 = node.target.index;	
													    	highlightNodes(index1,index2);

													    	d3.select(".nodesLabel")
								      							.append("text")
								      							.attr("class", "temporary")
								      							.text(`${node.source.name.match(/\w/)}`)
								      							.attr("x", (node.source.x0+node.source.x1)/2)
														      	.attr("y", (node.source.y0+node.source.y1)/2 +2)
														   		.attr("font-size", "10")
														   		.attr("font-weight", "300")
														   		.attr("text-anchor", "middle")
														   		.attr("fill", "DarkSalmon");

														   	d3.select(".nodesLabel")
								      							.append("text")
								      							.attr("class", "temporary")
								      							.text(`${node.target.name.match(/\w/)}`)
								      							.attr("x", (node.target.x0+node.target.x1)/2)
														      	.attr("y", (node.target.y0+node.target.y1)/2 +2)
														   		.attr("font-size", "10")
														   		.attr("font-weight", "300")
														   		.attr("text-anchor", "middle")
														   		.attr("fill", "DarkSalmon");
														})
							    .on("mouseout", function(event, node) { 
													    	d3.select(this).attr("stroke", (this.getAttribute("stroke")=="Tomato") ? "DarkSalmon" : "DarkSeaGreen")
													    	.attr("stroke-opacity", (this.getAttribute("stroke")=="DarkSalmon") ? 1 : 0.3);

													    	d3.select(".nodes")
																.selectAll("rect")
																.attr("fill", "white");

															d3.select(".temporary")
																.remove();
															d3.select(".temporary")
																.remove();

													    })
							   .on("click", function(event, node) { 
							    							node1 = node.source;
													    	node2 = node.target;

													    	permissionLink = true; //when permissionLink is true, it means a link has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
															var prevFilteredData = nextFilteredData;
								      						nextFilteredData = Array.from(d3.intersection(filterbyNL(inputData,node1,prevFilteredData),filterbyNL(inputData,node2,prevFilteredData)));  // I had to add Array.from here, comparing to click on node. to have nextFilteredData is an array format. I could not figure out why the results are different when I click on node or link. anyway it's OK now :) even when nextFilteredData is a Set, the code & function works. the only problem is when you want to download the word list. !!!!!!!!!!!!!!!!!!!!
								      						sankeyChart.select(".nodes").remove();
								      						sankeyChart.select(".links").remove();
								      						d3.select(".nodesLabel").remove();
								      						d3.select(".axis").remove();

								      						d3.select("#output")
								      							.select("span")
								      							.text(nextFilteredData.length);

								      						generateSankey(nextFilteredData, permissionLink); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
								      						drawSankey(nextFilteredData, permissionLink); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
								      						
								      						console.log("words on link click", words);
								      						console.log("data on link click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
								      						console.log("prevFilteredData on link click", prevFilteredData); //OK
															console.log("nextFilteredData on link click", nextFilteredData); //OK

															wordEmerge(nextFilteredData);

															
													    })
								
								.append("title")
							    .text(d => `${d.source.name} â†’ ${d.target.name}\n${values.get(d.source.name+d.target.name)}`);

				
					// Scale
					console.log("firstNode", realnodes[0]); //OK
					console.log("lastNode", realnodes[realnodes.length-1]); //OK

					range = [(realnodes[0].x0 + realnodes[0].x1)/2  , (realnodes[realnodes.length-1].x0+realnodes[realnodes.length-1].x1)/2];
					// console.log("range", range); //OK
					positionScale = d3.scaleLinear()
										.domain([1, L]) // which is L = d3.max(inputData, w => w.length])
									  	.range(range);

					
					// Axis my style
					positionAxis = d3.axisBottom(positionScale)
										// explicitly determining tick values & determining their format with 1 digit precision, prevents the problem of encountering ticks like 1.5 (which is meaningless for a position of a letter!) when L is small.
										.tickValues([...Array(L+1).keys()].slice(1,L+1))
										.tickFormat(d3.format("0.2"))
										.tickSizeOuter(0)
										.tickSizeInner(0)
										.tickPadding(0);

					sankeyChart.append("g")
								.attr("class", "axis")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(positionAxis)
								.attr("font-family", "hatch")
								.attr("font-size", "12")
								.attr("font-weight", "400")
								.attr("color", "navy")
								.select("path")
								.attr("stroke-opacity", 0);


					sankeyChart.select(".axis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", (range[0]+range[1])/2)
						        .attr("y", -15)
						        .attr("fill", "navy")
						        .attr("font-size", "12")
						        .attr("font-weight", "400")
						        .attr("text-anchor", "middle")
						        .text("LETTER INDEX");


				};


				// when click on white empty space, all links & node labels de-highlighted & 
				graphics.on("click",  function(event, element) {
											d3.select(".links")
												.selectAll("path")
												.attr("stroke-opacity", 0.3)
												.attr("stroke", "DarkSeaGreen");

											d3.select(".temporary")
												.remove();
										});
							


				
				// console.log("data in global scope", data); //OK
				drawSankey(data);


/////////// Draw Histogram

				////////////////////////////////////////// 
				////////////////////////////////////////// 
				// if you want to have a smaller chart with zoom=100% & no side effects like decrease/increase of font-size., play with "660" & "width" in the following two lines of code. & in the css style you should set grid.area for .histogram accordingly. NO NEED to touch anything else in the code. :)  *better to have a graph a bit smaller than the grid area just to make sure it's always 100% :)
				// var histoHeight = 660 - margin.top - margin.bottom;  
				// var histoWidth = width - margin.left - margin.right;
				//////////////////////////////////////////
				//////////////////////////////////////////
				var histoHeight = 660/1.5 - margin.top - margin.bottom;
				var histoWidth = d3.select(".sankey").node().getBBox().width /3 - margin.left - margin.right; // & set grid-area to half of the total coloum
				

				const histoChart = graphics.append("svg")
											.classed("histogram", true)
											.attr("viewBox", [0, 0, histoWidth + margin.left + margin.right, histoHeight + margin.top + margin.bottom ]);

				function drawHisto(inputData) {

				// Scales for smaller chart

				xScaleHisto = d3.scaleLinear()
							.domain([bins[0].x0, bins[bins.length-1].x1]) // -1  are to extend axis and add an extra tick just for appearance purpose. I will clear it later.  reasom :  x0 of the buckets are related to data domain. but not exactly. because when generating bins .thresholds(L) does not gaurantee to get L buckets!!! 
					   		.range([0, histoWidth]);

				yScaleHisto = d3.scaleLinear()
						    .domain([0, d3.max(bins, bucket => bucket.length)]).nice()
						    .range([histoHeight, 0]);


				// console.log("xScaleHisto domain", xScaleHisto.domain()); //OK

				histoChart.append("g")
							.attr("class", "histoRect")
							.attr("transform", `translate(${margin.left}, ${margin.top})`)
							.selectAll("rect")
							.data(bins)
							.join("rect")
					   		.attr("x", d => xScaleHisto(d.x0)) // -(xScaleHisto(b.x1)-xScaleHisto(b.x0))/2 is to center the rect on tick.
							.attr("width", d => Math.max(0, xScaleHisto(d.x1) - xScaleHisto(d.x0)-5)) // -5 just to add 5 pixel of white space btw rect elements
							.attr("y", d => yScaleHisto(d.length))
							.attr("height", d => yScaleHisto(0) - yScaleHisto(d.length))
							.attr("fill", "CornflowerBlue");

				rectWidth = d3.select(".histoRect").select("rect").node().getAttribute("width")
				;
				histoChart.append("g")
						    	.attr("class", "histoLabel")
								.attr("transform", "translate(" + margin.left + "," + margin.top  + ")")
								.selectAll("text")
								.data(bins)
								.join("text")
								.text(d => d.length)  
								.attr("x", d => xScaleHisto(d.x0)+rectWidth/2)
						      	.attr("y", d => yScaleHisto(d.length)-10)
						   		.attr("font-size", "12")
						   		.attr("font-weight", "400")
						   		.attr("text-anchor", "middle")
						   		.attr("fill", "CornflowerBlue");
				
				// Axis my style
				xAxisHisto = d3.axisBottom(xScaleHisto)
								.tickValues([...Array(L+1).keys()].slice(1,L+1))
								.tickSizeOuter(0)
								.tickSizeInner(0)
								.tickPadding(8)
								.tickFormat(d3.format("0.2"))
								// .ticks(L)
								

				histoChart.append("g")
							.attr("class", "xAxis")
							.attr("transform", `translate(${margin.left+rectWidth/2}, ${histoHeight+margin.top})`)
							.call(xAxisHisto)
							.attr("font-family", "hatch")
							.attr("font-size", "10")
							.attr("font-weight", "300")
							.attr("color", "grey");

				// clear those extra tick (first & last)  // it should be right after drawing axis. if later than that, the last of type wont be the last tick!!!!!!!!!
				
				histoChart.select(".xAxis")
							.selectAll(".tick:first-of-type text")
							.remove();
				// the following is required when xScaleHisto = d3.scaleLinear().domain([bins[0].x0-1, bins[bins.length-1].x1+1])	 // to remove that extra +1 tick at the end. other wise do not use this part:	
				// histoChart.select(".xAxis")
				// 			.selectAll(".tick:last-of-type text")
				// 			.remove();

				histoChart.select(".xAxis")
							.select("path")
							.remove();

				histoChart.select(".xAxis")
							.append("g")
							.attr("class", "axisLabel")
							.append("text")
					        .attr("x", xScaleHisto.range()[1]-rectWidth/2)
					        .attr("y", margin.bottom/2+12)
					        .attr("fill", "grey")
					        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
					        .attr("font-weight", "300")
					        .attr("text-anchor", "end")
					        .text("LENGTH");



				yAxisHisto = d3.axisLeft(yScaleHisto)
								.tickSizeOuter(0)
								.tickSizeInner(0)
								.ticks(0);

				histoChart.append("g")
							.attr("class", "yAxis")
							.attr("transform", `translate(${margin.left}, ${margin.top})`)
							.call(yAxisHisto)
							.attr("font-family", "hatch")
							.attr("font-size", "10")
							.attr("font-weight", "300")
							.attr("color", "grey")
							.select("path")
							.attr("stroke-opacity", 0.5);;

				histoChart.select(".yAxis")
							.append("g")
							.attr("class", "axisLabel")
							.append("text")
					        .attr("x", 0)
					        .attr("y", yScaleHisto.range()[1]-10) //yScaleHisto.range()[1]-margin.top+12
					        .attr("fill", "grey")
					        .attr("font-size", "10")
					        .attr("font-weight", "300")
					        .attr("text-anchor", "middle")
					        .text("WORD")
					        .text("COUNT");

				};


				drawHisto(mainWords);



/////////// Draw HeatMap
				var contourHeight = histoHeight; // = 660/1.5 - margin.top - margin.bottom; 
				var contourWidth = contourHeight; // width - margin.left - margin.right; // & set grid-area to half of the total coloum
				contourData = infoData(mainWords);
				config = {
						  paddingInner: 0, //0.1 of step, btw each bandwidth.
						  paddingOuter: 0, //0.2 of step, half of the sum of left & right outer paddings.
						  round: true, // ðŸ‘€ //rounding step to the closest integer
						  align: 0.5, //the ratio paddingOuter*2 will be devided btw left & right outer paddings.
						};

				xAlphabetScale= d3.scaleBand()
									.domain(d3.map(contourData, d => d.key[0]).sort()) //alphabet)
								  	.range([0, contourWidth])
								 	.paddingInner(config.paddingInner)
								  	.paddingOuter(config.paddingOuter)
								  	.align(config.align);

				yAlphabetScale= d3.scaleBand()
									.domain(d3.map(contourData, d => d.key[1]).sort()) //alphabet)
								  	.range([contourWidth, 0])
								 	.paddingInner(config.paddingInner)
								  	.paddingOuter(config.paddingOuter)
								  	.align(config.align);

				// console.log("xAlphabetScale domain", xAlphabetScale.domain()); //OK
				// console.log("xAlphabetScale bandwidth", xAlphabetScale.bandwidth()); //OK
				// console.log("yAlphabetScale domain", yAlphabetScale.domain()); //OK
				// console.log("yAlphabetScale bandwidth", yAlphabetScale.bandwidth()); //OK

				const heatMapChart = graphics.append("svg")
											.classed("heatMap", true)
											.attr("viewBox", [0, 0, heatMapWidth + margin.left + margin.right, heatMapHeight + margin.top + margin.bottom ]);

				// function drawContour(inputData) {
				// 	contourChart.append("g")
				// 				.attr("class", "dots")
				// 				.selectAll("circle")
				// 				.data(inputData)
				// 				.join("circle")
				// 		   		.attr("r", d => d.sameKeyCount/2) ///////// WORK ON THIS !!!!!!
				// 		   		.attr("cx", d => xAlphabetScale(d.key[0]))
				// 		   		.attr("cy", d => yAlphabetScale(d.key[1]))
				// 				.attr("transform", `translate(${margin.left+xAlphabetScale.bandwidth()/2}, ${margin.top+yAlphabetScale.bandwidth()/2})`)
				// 				.attr("fill", "blue")
				// 				.attr("opacity", 0.1);
			

				function drawHeatMap(inputData) {
					heatMapChart.append("g")
								.attr("class", "HeatMaprects")
								.selectAll("rect")
								.data(inputData)
								.join("rect")
						   		.attr("x", d => xAlphabetScale(d.key[0]))
								.attr("width", xAlphabetScale.bandwidth())
								.attr("y", d => yAlphabetScale(d.key[1]))
								.attr("height", yAlphabetScale.bandwidth())
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.attr("fill", "CornflowerBlue")
								.attr("stroke", "none")
								.attr("opacity", 0.1); ///// MAKE an OPACITY or Hue&Lightness SCALE. to relate countsameKey to colour channel.
				


					// Axis my style
					xAxisHeatMap = d3.axisBottom(xAlphabetScale)
										.tickValues(xAlphabetScale.domain())
										.tickSizeInner(0)
										.tickSizeOuter(0)
										.tickPadding(8) // 8 = 2/3*12(leading)

									

					heatMapChart.append("g")
								.attr("class", "xAxis")
								.attr("transform", `translate(${margin.left}, ${heatMapHeight+margin.top})`)
								.call(xAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey");

					heatMapChart.select(".xAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", xAlphabetScale.range()[1])
						        .attr("y", margin.bottom/2+12) // 12 = the leading for fontsize 10. (1.2*10=12)
						        .attr("fill", "grey")
						        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
						        .attr("font-weight", "300")
						        .attr("text-anchor", "end")
						        .text("FIRST LETTER");


			        yAxisHeatMap = d3.axisLeft(yAlphabetScale)
							.tickValues(yAlphabetScale.domain())
							.tickSizeInner(0)
							.tickSizeOuter(0)
							.tickPadding(8);

					heatMapChart.append("g")
								.attr("class", "yAxis")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.call(yAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey")
								.select("path")
								.attr("stroke-opacity", 0.5);;

					heatMapChart.select(".yAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", 0)
						        .attr("y", yAlphabetScale.range()[1]-10)
						        .attr("fill", "grey")
						        .attr("font-size", "10")
						        .attr("font-weight", "300")
						        .attr("text-anchor", "middle")
						        .text("WORD")
						        .text("LAST LETTER");
					
				};
				
				// drawheatMap(heatMapData);
				drawHeatMap(heatMapData);

/////////// Toolbar

			

				// Slider change
				function sliderUpdate(lengthLimit) {

					d3.select("#wordLength")
						.node()
						.setAttribute("value", lengthLimit);

       				// d3.select("#wordLength")
						// .clone();
						
					// d3.select("#wordLength")
					// 	.remove();


					d3.select("#slider")
						.select("span")
						.text(lengthLimit);

					
					sankeyChart.select(".nodes").remove();
					sankeyChart.select(".links").remove();
					d3.select(".nodesLabel").remove();
					d3.select(".axis").remove();
					d3.select(".words").remove();

					words = filterbyLength(mainWords, lengthLimit);
					console.log("words on slider change", words);
					generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
					drawSankey(words, false); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.


					d3.select("#output")
						.select("span")
						.text(words.length);
				};

				d3.select("#wordLength")
					.on("click", function() {
											lengthLimit = this.value;
											sliderUpdate(lengthLimit);
										});



				//Buttons

				d3.select("#reset")
					.select(".button")
					.on("click", function() {

										lengthLimit = d3.max(mainWords, w => w.length);
										sliderUpdate(lengthLimit);

										sankeyChart.select(".nodes").remove();
			      						sankeyChart.select(".links").remove();
										d3.select(".nodesLabel").remove();
										d3.select(".axis").remove();
										d3.select(".words").remove();

										words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));
			      						generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
			      						drawSankey(words, false);
			      						// set slider intial value to max length of the whole dataset
										// permissionNode=false;
										// permissionLink=false;

									});


				d3.select("#list")
					.select(".button")
					.on("click", function() {
									// console.log("nextFilteredData in download scope", nextFilteredData); //OK
									conent = nextFilteredData;
									header = "data:text/plain;charset=utf-8,"
									payload = header + encodeURIComponent(conent);

									this.href = payload;
								});



				






			  // alert("done");
			

			}); // this is the END of .then(function(rawdata) {...  after loading data :)


		</script>
		

	</body>
</html>
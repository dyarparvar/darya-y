<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Darya-Yarparvar__Graphic Designer</title>
		<meta name="description" content="Darya Yarparvar * Graphic Designer * Birmingham, UK * Open to work! ** Please visit my personal website and view my works. ** I would be more than happy to be of any help to your creative projects! **">
		<meta name="author" content="© 2021 Darya Yarparvar. All rights reserved.">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

		<link rel="preconnect" href="https://use.typekit.net/mok3rgv.css">
		
		
		<link rel="stylesheet" type="text/css" href="css/style.css">


		<link rel="stylesheet" type="text/css" href="css/icon-style.css">
		<link rel="stylesheet" href="https://use.typekit.net/mok3rgv.css">


		<base target="_blank">



        <script type="text/javascript" src="js/d3.js"></script>
        <script type="text/javascript" src="js/d3-sankey.js"></script>
       	
	</head>
	<body>
		
		
		<div id="wrapper">
			<div id="container" class="grid">
				
				<div id="flower">
					<h1>Word List Flower</h1>
					
				</div>

				<div id="context">
					<h1 id="heading">Scrabble Sankey</h1>
					<h3 id="intro">I could not resist choosing a playful subject to practice Sankey diagram... and I love word games! So here it is: <em>the scrabble sankey</em>! Play with it and have fun!</h3>
					<p><br><br>Words are strings of letters (spread horizontally). Each node represents a letter at a specific position. Each link connects two adjacent letters of a word.<br><br>This Sankey diagram is a multilevel network idiom that combines a node-link diagram with a derived cluster hirearchy, intending the path tracing as the main desired task.</p>
				</div>
					
				<div id="userGuide">
					<h2>How to use this visualisation:</h2>	
					<p>First, set the upper limit for words' length using the slider (the default is set to the longest word in the dataset).<br><br>Click on a node to narrow down the current word list to those words that have the selected letter at the selected position.<br><br>Click on a link to narrow down the current word list to those words that have the selected consecutive letters at those specific positions.<br><br>If you click on the slider without changing its value, the word list filteration caused by clicking node/link will be reset to none.<br><br>You can download the list of the words at whatever step you like :)</p>
				</div>
					
				
				<!-- <div id="legend">
						<h3>How to read the chart</h3>	
				</div> -->



				<div id="slider">
				  	<label for="wordLength">Set the word length limit</label>
					<input type="range" min="1" max="31" value="10" id="wordLength">
				</div>

				<div id="output">
					<h3>How many words?</h3>
					<span></span>
				</div>

				<div id="special">
					<a href="">*</a>
					<a href="">*</a>

				</div>


				<div id="reset">
					<a class="button">Reset</a>
				</div>

			  	<div id="list">
					<a href="" download="selected-word-list.txt" class="button">Download</a>
				</div>


				<div id="graphics" class="grid">

				</div>


				<!-- <div id="file">
				  	<label for="dataFile">You can upload your own word list [in .txt format] & play with the diagram! </label>
					<input type="file" name="loadData" id="dataFile">
				</div> -->


				<div id="footnotes">
						<h2>footnotes & methods</h2>	
				</div>



					
			</div>
				


				
				
				




				



			</div>
			
			
		</div>

<!--
*****************************
****************************
***************************
************************** Data Visualisation Code __ START 
***************************
****************************
******************************
-->


		<script type="text/javascript">
			
/////// Settings (width, height, margin,)

			

			var width = screen.availWidth,
				height = screen.availHeight,

			padding = {top: 60, right: 60, bottom: 60, left: 60},
			margin = {top: 60, right: 50, bottom: 60, left: 50};
			deltaAxis = 40;

			// margin = {top: 150, right: 50, bottom: 100, left: 250}; //trial

			const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
			const vowels = ["a","e","i","o","u"];
			const consonents = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"];


/////// Load & Read data
			
	/////// OPTION 1 : Load in raw JSON data & THEN...
			// d3.json("data/words_dictionary-test.json").then(function(rawdata) {  //I deleted "jean-christophe": 1, from data. due to - character.
			// 	// console.log(rawdata); //OK
			// 	// mainWords = d3.csvParseRows(rawdata, line => line.toString());
			// 	var mainWords = [...d3.difference(Object.keys(rawdata),alphabet)]; //exclude alphabet because they are single letters & no node/link meaning.
			// 	console.log("mainWords", mainWords); //OK	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/////// OPTION 2 : Load in raw TEXT data & THEN...
			d3.text("data/list.txt").then(function(rawdata) {
				// console.log(rawdata); //OK
				mainWords = [...d3.difference(d3.csvParseRows(rawdata, line => line.toString().toLowerCase()),alphabet)]; // I deleted "won't" & "don't" 
				console.log("mainWords", mainWords); //OK	 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////// Initiation

				
				// the length of the longest word	
				// L = d3.max(mainWords, w => w.length);   //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length) in this part : words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));, then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				// console.log("max word length", L); //OK
				

				
				// Slider settings
				// set slider intial value to max length of the whole dataset
				d3.select("#wordLength")
					.node()
					.setAttribute("max", d3.max(mainWords, w => w.length));
				d3.select("#wordLength")
					.node()
					.setAttribute("value", d3.max(mainWords, w => w.length));

				d3.select("#slider")
					.append("span")
					.text(d3.select("#wordLength").node().value);

				// Output
				d3.select("#output")
					.select("span")
					.text(mainWords.length);



/////////// Sankey Data Preperation
				function prepareData(inputData) {

					console.log("inputData in prepareData scope", inputData); //OK

					
					//the length of the longest word	
					L = d3.max(inputData, w => w.length);
					console.log("max word length", L); //OK
					

					// Nodes
					var nodes = [];
					d3.map(alphabet, letter => { for (let i=1; i<=L; i++) {
													nodes.push({
																name: letter+i,
															});
													}
												});
					console.log("nodes", nodes); //OK

				    // Links
					var links = [];

					var letterByletter = d3.map(inputData, w => Array.from(w));
					// console.log("letterByletter", letterByletter); //OK
					d3.map(letterByletter, array => { for (let i=0; i<array.length-1; i++) {
														links.push({
															word : array.join(""),
															source : array[i]+(i+1),
															target : array[(i+1)]+(i+2),
															value : 1,
															});
														}
													});
					console.log("links", links); //OK

					values = d3.rollup(links, g => g.length, obj => obj.source+obj.target);
					console.log("values", values); //OK

					// Data for Sankey
					var data = {
								nodes : nodes.map(d => Object.assign({}, d)),
								links : links.map(d => Object.assign({}, d))
							};
					console.log("data in prepareData scope", data); //OK

					return {data : data,
							L : L} ;
				};


/////////// Flower Data Preperation
				function prepareFlowerData(inputData) {
					L = d3.max(inputData, w => w.length);

					// Nodes
					var flowerNodes = [];
					d3.map(inputData, word => { for (let i=0; i<word.length; i++) {
													flowerNodes.push({
																code: word,
																name: word[i]+(i+1) + "/" + word,
																key: word[i]+(i+1)
															});
													}
												});
					console.log("flowerNodes", flowerNodes); //OK

				    // Links
					var flowerLinks = [];

					var letterByletter = d3.map(inputData, w => Array.from(w));
					console.log("letterByletter", letterByletter); //OK
					d3.map(letterByletter, array => { for (let i=0; i<array.length-1; i++) {
														flowerLinks.push({
															word : array.join(""),
															sourceKey: array[i]+(i+1),
															targetKey: array[(i+1)]+(i+2),
															source : array[i]+(i+1) + "/" + array.join("") ,
															target : array[(i+1)]+(i+2) + "/" + array.join(""),
															value : 1,
															});
														}
													});
					console.log("flowerLinks", flowerLinks); //OK

					flowerValues = d3.rollup(flowerLinks, g => g.length, obj => (obj.sourceKey) + (obj.targetKey));
					console.log("flowerValues", flowerValues); //OK

					// Data for Sankey
					var flowerData = {
								nodes : flowerNodes.map(d => Object.assign({}, d)),
								links : flowerLinks.map(d => Object.assign({}, d))
							};
					console.log("flowerData in flowerData scope", flowerData); //OK

					return {data : flowerData,
							L : L} ;
				};

				



/////////// BubblePlot Data Preparation
				// function bubbleData(inputData) {
				// 	wordInfo = d3.map(inputData, w => { 
				// 										return {
				// 											word: w,
				// 											key: w[0]+w[w.length-1],
				// 											sameKey: d3.group(inputData, w => w[0]+w[w.length-1]).get(w[0]+w[w.length-1]),
				// 											sameKeyCount: d3.rollup(inputData, g => g.length, w => w[0]+w[w.length-1]).get(w[0]+w[w.length-1]),
				// 											length: w.length,
				// 											sameLength:  d3.group(inputData, w => w.length).get(w.length),
				// 											sameLengthCount:  d3.rollup(inputData, g => g.length, w => w.length).get(w.length)
				// 										};
				// 									});
					
				// 	return wordInfo;
				// };
				// console.log("bubbleData", bubbleData(mainWords)); //OK



				// Draw Bubble Plot (initial attempt)
				// function drawBubblePlot(inputData) {
				// 		heatMapChart.append("g")
				// 					.attr("class", "dots")
				// 					.selectAll("circle")
				// 					.data(inputData)
				// 					.join("circle")
				// 			   		.attr("r", d => d.sameKeyCount/2) ///////// WORK ON THIS !!!!!!
				// 			   		.attr("cx", d => xAlphabetScale(d.key[0]))
				// 			   		.attr("cy", d => yAlphabetScale(d.key[1]))
				// 					.attr("transform", `translate(${margin.left+xAlphabetScale.bandwidth()/2}, ${margin.top+yAlphabetScale.bandwidth()/2})`)
				// 					.attr("fill", "blue")
				// 					.attr("opacity", 0.1);


/////////// HeatMap Data Preparation
				function heatmapInfo(inputData) {
					heatmapData = d3.flatGroup(inputData, w => w[0]+w[w.length-1]);
					return heatmapData;
				};
				console.log("heatmapData", heatmapInfo(mainWords)); //OK



	
/////////// Interactivity
				function highlightAdjLinks(n) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  p => (p.source.index == n.index || p.target.index == n.index) ? 1 : 0.3)
						.attr("stroke", p => (p.source.index == n.index || p.target.index == n.index) ? "DarkSalmon" : "DarkSeaGreen");
				};

				function unhighlightAdjLinks(n) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  p => (p.source.index == n.index || p.target.index == n.index) ? 0.3 : 0.3)
						.attr("stroke", p => (p.source.index == n.index || p.target.index == n.index) ? "DarkSeaGreen" : "DarkSeaGreen");
				};


				function highlightNodes(n1, n2) {
				    d3.select(".nodes")
						.selectAll("rect")
						.attr("fill", rect => (rect.index == n1 || rect.index == n2) ? "navy" : "white");
				};


				function filterbyNL(inputData, node, filteredData) {
					nextFilteredData = d3.filter(filteredData, w => (w[(node.depth+1)-1] == node.name.match(/\w/)));
					console.log("prevFilteredData in filter scope", filteredData); //OK
					console.log("nextFilteredData in filter scope", nextFilteredData); //OK
					return nextFilteredData;
				};


				function filterbyLength(inputData, lengthLimit) {
					limitedData = d3.filter(inputData, w => (w.length <= lengthLimit));
					console.log("limitedData in filterbyLength scope", limitedData); //OK
					return limitedData;
				};


				// Word emerge !
				function wordList(filteredData) {
					if (filteredData.length <= 10) {
						if (!graphics.select(".words").node()) {  
							graphics.append("g")
									.attr("transform", `translate(${margin.left}, ${margin.top})`)
									.attr("class", "words")
									.selectAll("text")
									.data(filteredData)
									.join("text")
									.text(d => d)

							} else {
							graphics.select(".words")
									.selectAll("text")
									.data(filteredData)
									.join("text")
									.text(d => d)
						}
					};
				};



				// words starting with this letter:
				function startLetter(inputData,letter) {
					(!letter) ? letter = w[0] : letter = letter.toString();
					return d3.group(inputData, w => w[0]).get(letter);
				};
				// console.log("words starting with this Letter", startLetter(mainWords, "c")); //OK //for example all the words starting with c.
				
				// words ending with this letter:
				function endLetter(inputData,letter) {
					(!letter) ? letter = w[w.length-1] : letter = letter.toString();
					return d3.group(inputData, w => w[w.length-1]).get(letter);
				};
				// console.log("words ending with this Letter", endLetter(mainWords, "c")); //OK //for example all the words ending with c.
				
				
				// Word Key
				function keyWords(keyData) {
					if (!graphics.select(".keyWords").node()) {  //if there's no .keyWords already made, first make one & the append <text>s & ...
						graphics.append("g")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.attr("class", "keyWords")
								.selectAll("text")
								.data(keyData)
								.join("text")
								.text(d => d)

						} else {  //if .keyWords has already been made, just append <text>s & ...
						graphics.select(".keyWords")
								.selectAll("text")
								.data(keyData)
								.join("text")
								.text(d => d)
					};
					
				};


/////////// Sankey Generator
				var sankeyHeight = 660 - margin.top - margin.bottom - deltaAxis; //height*1.2;
				var sankeyWidth = width - margin.top - margin.bottom;

				function generateSankey(inputData, permission) {   //better to use prepareData inside this function. data still will be available at global scope. and you have control on updating sankey generator based on filtered data.
					
					// console.log("data in generateSankey scope", data); //here data is not defined yet. and so not L.
					data = prepareData(inputData).data;
					L = prepareData(inputData).L; //the first time you are gonna define data. data will be at global scope.
					console.log("data in generateSankey scope", data); // OK.  here data is defined. and so is L :)
					console.log("L in generateSankey scope", L); // OK.  here data is defined. and so is L :)

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodeWidth(((sankeyWidth/(L+1))/5))
						      	.nodePadding(0)
						      	// .nodeSort((node1,node2) => d3.ascending(node1.name, node2.name)) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    .linkSort(d3.descending) // it seems without node sorting the results are better!!!! no node crashing ?!?!?!?!?!?!!?!?!!?!?
						      	.extent([[1,1], [sankeyWidth- 1, sankeyHeight- 1]]);

					sankey(data);

					// filtering out those nodes that has value = 0. 
					realnodes = d3.filter(data.nodes, node => (node.value!=0));
					// sort the nodes first based on the KEY digits (either 2 digits , if null then 1 digit)  & then based on the KEY letter
					realnodes.sort((a,b) => ( (a.name.match(/\d{2}/)|| a.name.match(/\d{1}/)) - (b.name.match(/\d{2}/) || b.name.match(/\d{1}/)) )    ||    (a.name.match(/\w{1}/) - b.name.match(/\w{1}/)) );
					// console.log("realnodes",realnodes); //OK

					// fixing the place of a..z nodes at each position (parallel lines with fixed x , width & distance)
					d3.map(realnodes, node => { 
												distance = sankeyWidth/(L+1);
												nodeWidth = distance/5;

												node.x0 = (node.depth+1)*distance-(nodeWidth/2);
												node.x1 = node.x0+nodeWidth;

												
												// console.log("max nodes at any position?"); //OK
												name = node.name.match(/\w/);
												nodeHeight= sankeyHeight/26;
												// // OPTION 1 : this conditional part of code fixes y0,y1,height of the nodes at overview state. at detail state(click on node/link) the height of nodes encodes their value.
												// if (!permission) {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	node.y1 = node.y0 + nodeHeight;
												// }
												// OPTION 2 : this UNconditional part of code fixes y0,y1,height of the nodes at overview & detail states (click on node/link) & the height of nodes NEVER encodes anything & its always constant.
												{
													d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
													node.y1 = node.y0 + nodeHeight;
												} 
												// OPTION 3 : this condition fixes y0,y1,height of the nodes at detail states (click on node/link) & the height of nodes DO STH!!!!!! ?????!??? 
												// else {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	// node.y1 = node.y0 + nodeHeight;
												// } 
												
											}
									);

					// fixing the place of links. so all links between two specific nodes are on top of each other. & also each node only encodes the item. and NOT the value. all nodes will have equal length. (fixed y & length)
					d3.map(data.links, link => { 
												link.y0 = (link.source.y0+link.source.y1)/2;
												link.y1 = (link.target.y0+link.target.y1)/2;
											}
									);
				};


/////////// Histogram Generator
			  
				function histo(inputData) {
					lengthValues = d3.map(inputData, w => w.length);
					buckets = d3.bin()
								.thresholds(d3.max(inputData, w => w.length));//.thresholds(L) does not gaurantee to recieve L buckets!!! like d3.ticks. 
					// histogram = d3.histogram()
					// 				.thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()); //// you can define your own function .thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()) this example classifies words with respect to their initial letters if the values are inputData=words. 
					// BUT WHY d3.histogram does not work?!?!?!?
					// console.log(buckets.domain()(lengthValues)); //OK by default the domain is the extend of inputData
					return buckets(lengthValues);
				};


/////////// Flower Generator
				var flowerHeight = 660 - margin.top - margin.bottom;
				var flowerWidth = 660 - margin.left - margin.right; //flowerHeight; //width - margin.top - margin.bottom;

				function generateFlower(inputData, permission) {
					wordNumbers = inputData.length;
					data = prepareFlowerData(inputData).data;
					L = prepareFlowerData(inputData).L;

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	// .nodeWidth(((flowerWidth/(L+1))/5))
						      	.nodePadding(0)
						      	// .nodeSort((node1,node2) => d3.ascending(node1.name, node2.name)) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    .linkSort(d3.descending) // it seems without node sorting the results are better!!!! no node crashing ?!?!?!?!?!?!!?!?!!?!?
						      	.extent([[1,1], [flowerWidth- 1, flowerHeight- 1]]);

					sankey(data);
					// NO NEED to filtering out those nodes that has value = 0. ALL the links are valid ! no link with value = 0 :)
					realnodes = d3.filter(data.nodes, node => node);
					// console.log("flowerrealnodes",realnodes); //OK

					// fixing the place of a..z nodes at each position (parallel lines with fixed x , width & distance)
					d3.map(realnodes, node => { 
												distance = (flowerWidth/(L+1))/1.5;
												phi = 2*Math.PI/wordNumbers;
												r = distance/40;
												// console.log("phi", phi); //OK

												node.radius = (node.name.match(/\d{2}/) || node.name.match(/\d{1}/))*distance - 2*r;

												d3.map(inputData, word => (node.code == word) ? node.angle = inputData.indexOf(word)*phi : 0);

												node.cx = Math.sin(node.angle)*node.radius ;
												node.cy = Math.cos(node.angle)*node.radius ;											
											}
									);


					d3.map(data.links, link => { 
												link.sourcePosition = [link.target.cx, link.target.cy];
												link.targetPosition = [link.source.cx, link.source.cy];
											}
									);

					// modify d3.sankeyLinkHorizontal() to get the link information from link.sourcePosition & link.targetPosition keys instead of x0,y0 & x1,y1.
					flowerLink = d3.sankeyLinkHorizontal()
								.source(d => d.sourcePosition)
								.target(d => d.targetPosition);
				};



/////////// Graphics
				const graphics = d3.select("#graphics");
				const flower = d3.select("#flower");

/////////// Draw Sankey
				const sankeyChart = graphics.append("svg")
										.classed("sankey", true)
										.attr("viewBox", [0, 0, sankeyWidth + margin.left + margin.right , sankeyHeight + margin.top + margin.bottom + deltaAxis]);
				
				
				function drawSankey(inputData, permission) {
					words = filterbyLength(inputData, d3.max(inputData, w => w.length));
					generateSankey(words, permission);

					console.log("data in drawSankey scope", data); //OK
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ; //here if any of nodes has been already clicked the nextFilterData wont be reset to words :) so consecutive clicking will result in step by step filtering and selection of words based on each clicked node & ultimately shrinking the inputData :)

					

					// Links
				    sankeyChart.append("g")
							    .attr("class", "links")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
							    .selectAll("path")
							    .data(data.links)
							    .join("path")
							    .attr("d", d3.sankeyLinkHorizontal())
							    .attr("fill", "none")
							    .attr("stroke", "DarkSeaGreen")
							    .attr("stroke-width", 1) //if you want to encode link values with width, generally use d => Math.min(1, d.width) or for our case d => values.get(d.source.name+d.target.name) instead of d.width.
							    .attr("stroke-opacity", 0.3)
							    .on("mouseover", function(event, node) { 
													    	d3.select(this)
													    		.attr("stroke", (this.getAttribute("stroke")=="DarkSalmon") ? "Tomato" : "navy")
													    		.attr("stroke-opacity", 1);

													    	index1 = node.source.index;
													    	index2 = node.target.index;	
													    	highlightNodes(index1,index2);

													    	d3.select(".nodesLabel")
								      							.append("text")
								      							.attr("class", "temporary")
								      							.text(`${node.source.name.match(/\w/)}`)
								      							.attr("x", (node.source.x0+node.source.x1)/2)
														      	.attr("y", (node.source.y0+node.source.y1)/2 +2)
														   		.attr("font-size", "10")
														   		.attr("font-weight", "300")
														   		.attr("text-anchor", "middle")
														   		.attr("fill", "DarkSalmon");

														   	d3.select(".nodesLabel")
								      							.append("text")
								      							.attr("class", "temporary")
								      							.text(`${node.target.name.match(/\w/)}`)
								      							.attr("x", (node.target.x0+node.target.x1)/2)
														      	.attr("y", (node.target.y0+node.target.y1)/2 +2)
														   		.attr("font-size", "10")
														   		.attr("font-weight", "300")
														   		.attr("text-anchor", "middle")
														   		.attr("fill", "DarkSalmon");
														})
							    .on("mouseout", function(event, node) { 
													    	d3.select(this).attr("stroke", (this.getAttribute("stroke")=="Tomato") ? "DarkSalmon" : "DarkSeaGreen")
													    	.attr("stroke-opacity", (this.getAttribute("stroke")=="DarkSalmon") ? 1 : 0.3);

													    	d3.select(".nodes")
																.selectAll("rect")
																.attr("fill", "white");

															d3.select(".temporary")
																.remove();
															d3.select(".temporary")
																.remove();

													    })
							   .on("click", function(event, node) { 
							    							node1 = node.source;
													    	node2 = node.target;

													    	permissionLink = true; //when permissionLink is true, it means a link has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
															var prevFilteredData = nextFilteredData;
								      						nextFilteredData = Array.from(d3.intersection(filterbyNL(inputData,node1,prevFilteredData),filterbyNL(inputData,node2,prevFilteredData)));  // I had to add Array.from here, comparing to click on node. to have nextFilteredData is an array format. I could not figure out why the results are different when I click on node or link. anyway it's OK now :) even when nextFilteredData is a Set, the code & function works. the only problem is when you want to download the word list. !!!!!!!!!!!!!!!!!!!!
								      						sankeyChart.select(".nodes").remove();
								      						sankeyChart.select(".links").remove();
								      						d3.select(".nodesLabel").remove();
								      						d3.select(".axis").remove();

								      						d3.select("#output")
								      							.select("span")
								      							.text(nextFilteredData.length);

								      						generateSankey(nextFilteredData, permissionLink); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
								      						drawSankey(nextFilteredData, permissionLink); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
								      						
								      						console.log("words on link click", words);
								      						console.log("data on link click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
								      						console.log("prevFilteredData on link click", prevFilteredData); //OK
															console.log("nextFilteredData on link click", nextFilteredData); //OK

															wordList(nextFilteredData);

															
													    })
								
								.append("title")
							    .text(d => `${d.source.name} → ${d.target.name}\n${values.get(d.source.name+d.target.name)}`);

					// Nodes
					sankeyChart.append("g")
								.attr("class", "nodes")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
						    	.selectAll("rect")
						    	.data(realnodes) //here since nodes with value=0 has been filtered at generateSankey , instead of using data.nodes, use realnodes & get rid of such a condition at each step of drawing nodes : d => (d.value!=0) ? d.x0 : 100)
						    	.join("rect")
						     	.attr("x", d => d.x0)
						      	.attr("y", d => d.y0)
						      	.attr("height", d => (d.y1 - d.y0))
						      	.attr("width", d => (d.x1 - d.x0))
						      	.attr("fill", "white")
						      	.attr("stroke", "navy")
						      	.on("mouseover", function(event, node) {
										      		nodeData = this.__data__;
						      						d3.select(this) //"this" is each <rect>
						      							.attr("fill", "navy")
						      						d3.select(".nodesLabel")
						      							.append("text")
						      							.attr("class", "temporary")
						      							.text((nodeData.value != 0) ? `${nodeData.name.match(/\w/)}`: "")
						      							.attr("x", (nodeData.x0+nodeData.x1)/2)
												      	.attr("y", (nodeData.y0+nodeData.y1)/2 +2)
												   		.attr("font-size", "10")
												   		.attr("font-weight", "300")
												   		.attr("text-anchor", "middle")
												   		.attr("fill", "DarkSalmon");
						      						highlightAdjLinks(node); //node as the second input of a function applied on an event is directly the bind data itself.

										      	})
						      	.on("mouseout", function(event, node){
						      						d3.select(this)
						      							.attr("fill", "white");

						      						d3.select(".temporary")
														.remove();

						      						// unhighlightAdjLinks(node);
						      									
										      	})
						      	.on("click", function (event, node) {
						      						permissionNode = true; //when permissionNode is true, it means a node has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
													var prevFilteredData = nextFilteredData;
						      						nextFilteredData = filterbyNL(inputData,node,prevFilteredData);
						      						sankeyChart.select(".nodes").remove();
						      						sankeyChart.select(".links").remove();
						      						d3.select(".nodesLabel").remove();
						      						d3.select(".axis").remove();



						      						d3.select("#output")
						      							.select("span")
						      							.text(nextFilteredData.length);

						      						generateSankey(nextFilteredData,permissionNode); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
						      						drawSankey(nextFilteredData, permissionNode); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
						      						
						      						console.log("words on node click", words);
						      						console.log("data on node click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
						      						console.log("prevFilteredData on node click", prevFilteredData); //OK
													console.log("nextFilteredData on node click", nextFilteredData); //OK
						      						highlightAdjLinks(node);

						      						wordList(nextFilteredData);

						      						
												      	})
						    	.append("title")
						    	.text(d => `${d.value}`); // ${d.name}\n${d.value}

					// Node Labels

			    	sankeyChart.append("g")
						    	.attr("class", "nodesLabel")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
								.selectAll("text")
								.data(data.nodes)
								.join("text")
								.text(d => (d.value != 0) ? `${d.name.match((/\w/))}`: "")  
								.attr("x", d => d.x0+((sankeyWidth/(L+1))/10)) // x0 + nodeWidth/2
						      	.attr("y", d => (d.y0+d.y1)/2 +2) // +2 comes from this : lineheight(set equal to 1.2*fontsize at the * {} in style.css) - labelfontsize = 12 - 10 = 2 :)
						   		.attr("font-size", "10")
						   		.attr("font-weight", "300")
						   		.attr("text-anchor", "middle")
						   		.attr("fill", "navy");

				
					// Scale
					console.log("firstNode", realnodes[0]); //OK
					console.log("lastNode", realnodes[realnodes.length-1]); //OK

					range = [(realnodes[0].x0 + realnodes[0].x1)/2  , (realnodes[realnodes.length-1].x0+realnodes[realnodes.length-1].x1)/2];
					// console.log("range", range); //OK
					positionScale = d3.scaleLinear()
										.domain([1, L]) // which is L = d3.max(inputData, w => w.length])
									  	.range(range);

					
					// Axis my style
					positionAxis = d3.axisBottom(positionScale)
										// explicitly determining tick values & determining their format with 1 digit precision, prevents the problem of encountering ticks like 1.5 (which is meaningless for a position of a letter!) when L is small.
										.tickValues([...Array(L+1).keys()].slice(1,L+1))
										.tickFormat(d3.format("0.2"))
										.tickSizeOuter(0)
										.tickSizeInner(0)
										.tickPadding(0);

					sankeyChart.append("g")
								.attr("class", "axis")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(positionAxis)
								.attr("font-family", "hatch")
								.attr("font-size", "12")
								.attr("font-weight", "400")
								.attr("color", "navy")
								.select("path")
								.attr("stroke-opacity", 0);


					sankeyChart.select(".axis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", (range[0]+range[1])/2)
						        .attr("y", -15)
						        .attr("fill", "navy")
						        .attr("font-size", "12")
						        .attr("font-weight", "400")
						        .attr("text-anchor", "middle")
						        .text("LETTER INDEX");


				};


				// when click on white empty space, all links & node labels de-highlighted & 
				graphics.on("click",  function(event, element) {
											d3.select(".links")
												.selectAll("path")
												.attr("stroke-opacity", 0.3)
												.attr("stroke", "DarkSeaGreen");

											d3.select(".temporary")
												.remove();
										});
							


				
				// console.log("data in global scope", data); //OK
				drawSankey(mainWords);


/////////// Draw Histogram

				////////////////////////////////////////// 
				////////////////////////////////////////// 
				// if you want to have a smaller chart with zoom=100% & no side effects like decrease/increase of font-size., play with "660" & "width" in the following two lines of code. & in the css style you should set grid.area for .histogram accordingly. NO NEED to touch anything else in the code. :)  *better to have a graph a bit smaller than the grid area just to make sure it's always 100% :)
				// var histoHeight = 660 - margin.top - margin.bottom;  
				// var histoWidth = width - margin.left - margin.right;
				//////////////////////////////////////////
				//////////////////////////////////////////
				var histoHeight = 660/1.5 - margin.top - margin.bottom;
				var histoWidth = d3.select(".sankey").node().getBBox().width /3 - margin.left - margin.right; // & set grid-area to half of the total coloum
				

				const histoChart = graphics.append("svg")
											.classed("histogram", true)
											.attr("viewBox", [0, 0, histoWidth + margin.left + margin.right, histoHeight + margin.top + margin.bottom ]);

				function drawHisto(inputData) {

				bins = histo(inputData);
				console.log("bins", bins); //OK

				// Scales for smaller chart

				xScaleHisto = d3.scaleLinear()
							.domain([bins[0].x0, bins[bins.length-1].x1]) // -1  are to extend axis and add an extra tick just for appearance purpose. I will clear it later.  reasom :  x0 of the buckets are related to data domain. but not exactly. because when generating bins .thresholds(L) does not gaurantee to get L buckets!!! 
					   		.range([0, histoWidth]);

				yScaleHisto = d3.scaleLinear()
						    .domain([0, d3.max(bins, bucket => bucket.length)]).nice()
						    .range([histoHeight, 0]);


				// console.log("xScaleHisto domain", xScaleHisto.domain()); //OK

				histoChart.append("g")
							.attr("class", "histoRect")
							.attr("transform", `translate(${margin.left}, ${margin.top})`)
							.selectAll("rect")
							.data(bins)
							.join("rect")
					   		.attr("x", d => xScaleHisto(d.x0)) // -(xScaleHisto(b.x1)-xScaleHisto(b.x0))/2 is to center the rect on tick.
							.attr("width", d => Math.max(0, xScaleHisto(d.x1) - xScaleHisto(d.x0)-5)) // -5 just to add 5 pixel of white space btw rect elements
							.attr("y", d => yScaleHisto(d.length))
							.attr("height", d => yScaleHisto(0) - yScaleHisto(d.length))
							.attr("fill", "CornflowerBlue");

				rectWidth = d3.select(".histoRect").select("rect").node().getAttribute("width");

				histoChart.append("g")
						    	.attr("class", "histoLabel")
								.attr("transform", "translate(" + margin.left + "," + margin.top  + ")")
								.selectAll("text")
								.data(bins)
								.join("text")
								.text(d => d.length)  
								.attr("x", d => xScaleHisto(d.x0)+rectWidth/2)
						      	.attr("y", d => yScaleHisto(d.length)-10)
						   		.attr("font-size", "12")
						   		.attr("font-weight", "400")
						   		.attr("text-anchor", "middle")
						   		.attr("fill", "CornflowerBlue");
				
				// Axis my style
				L = d3.max(inputData, w => w.length);
				xAxisHisto = d3.axisBottom(xScaleHisto)
								.tickValues([...Array(L+1).keys()].slice(1,L+1))
								.tickSizeOuter(0)
								.tickSizeInner(0)
								.tickPadding(8)
								.tickFormat(d3.format("0.2"))
								// .ticks(L)
								

				histoChart.append("g")
							.attr("class", "xAxis")
							.attr("transform", `translate(${margin.left+rectWidth/2}, ${histoHeight+margin.top})`)
							.call(xAxisHisto)
							.attr("font-family", "hatch")
							.attr("font-size", "10")
							.attr("font-weight", "300")
							.attr("color", "grey");

				// clear those extra tick (first & last)  // it should be right after drawing axis. if later than that, the last of type wont be the last tick!!!!!!!!!
				
				histoChart.select(".xAxis")
							.selectAll(".tick:first-of-type text")
							.remove();
				// the following is required when xScaleHisto = d3.scaleLinear().domain([bins[0].x0-1, bins[bins.length-1].x1+1])	 // to remove that extra +1 tick at the end. other wise do not use this part:	
				// histoChart.select(".xAxis")
				// 			.selectAll(".tick:last-of-type text")
				// 			.remove();

				histoChart.select(".xAxis")
							.select("path")
							.remove();

				histoChart.select(".xAxis")
							.append("g")
							.attr("class", "axisLabel")
							.append("text")
					        .attr("x", xScaleHisto.range()[1]-rectWidth/2)
					        .attr("y", margin.bottom/2+12)
					        .attr("fill", "grey")
					        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
					        .attr("font-weight", "300")
					        .attr("text-anchor", "end")
					        .text("LENGTH");



				yAxisHisto = d3.axisLeft(yScaleHisto)
								.tickSizeOuter(0)
								.tickSizeInner(0)
								.ticks(0);

				histoChart.append("g")
							.attr("class", "yAxis")
							.attr("transform", `translate(${margin.left}, ${margin.top})`)
							.call(yAxisHisto)
							.attr("font-family", "hatch")
							.attr("font-size", "10")
							.attr("font-weight", "300")
							.attr("color", "grey")
							.select("path")
							.attr("stroke-opacity", 0.5);;

				histoChart.select(".yAxis")
							.append("g")
							.attr("class", "axisLabel")
							.append("text")
					        .attr("x", 0)
					        .attr("y", yScaleHisto.range()[1]-10) //yScaleHisto.range()[1]-margin.top+12
					        .attr("fill", "grey")
					        .attr("font-size", "10")
					        .attr("font-weight", "300")
					        .attr("text-anchor", "middle")
					        .text("WORD")
					        .text("COUNT");

				};


				drawHisto(mainWords);



/////////// Draw HeatMap
				var heatMapHeight = histoHeight; // = 660/1.5 - margin.top - margin.bottom; 
				var heatMapWidth = heatMapHeight;
				

				const heatmapChart = graphics.append("svg")
											.classed("heatmap", true)
											.attr("viewBox", [0, 0, heatMapWidth + margin.left + margin.right, heatMapHeight + margin.top + margin.bottom ]);
							
			

				function drawHeatMap(inputData) {

					heatmapData = heatmapInfo(inputData);

					config = {
							  paddingInner: 0,
							  paddingOuter: 0,
							  round: false, //rounding step to the closest integer
							  align: 0.5, //the ratio paddingOuter*2 will be devided btw left & right outer paddings.
							};

					xAlphabetScale = d3.scaleBand()
										.domain(d3.map(heatmapData, d => d[0][1]).sort(d3.ascending)) //alphabet)
									  	.range([0, heatMapWidth])
									 	.paddingInner(config.paddingInner)
									  	.paddingOuter(config.paddingOuter)
									  	.align(config.align)
									  	.round(config.round);

					yAlphabetScale = d3.scaleBand()
										.domain(d3.map(heatmapData, d => d[0][0]).sort(d3.descending)) //alphabet)
									  	.range([heatMapWidth, 0])
									 	.paddingInner(config.paddingInner)
									  	.paddingOuter(config.paddingOuter)
									  	.align(config.align)
									  	.round(config.round);

					// console.log("xAlphabetScale domain", xAlphabetScale.domain()); //OK
					// console.log("xAlphabetScale bandwidth", xAlphabetScale.bandwidth()); //OK
					// console.log("yAlphabetScale domain", yAlphabetScale.domain()); //OK
					// console.log("yAlphabetScale bandwidth", yAlphabetScale.bandwidth()); //OK

					colourScale = d3.scaleLinear()
									.domain(d3.extent(heatmapData, info => info[1].length))
									.range(["#f2eded", "Tomato"]);
					// console.log("colourScale domain", colourScale.domain()); //OK

					// Rects
					heatmapChart.append("g")
								.attr("class", "heatmapRects")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.selectAll("rect")
								.data(heatmapData)
								.join("rect")
						   		.attr("x", d => xAlphabetScale(d[0][1]))
								.attr("width", xAlphabetScale.bandwidth())
								.attr("y", d => yAlphabetScale(d[0][0]))
								.attr("height", yAlphabetScale.bandwidth())
								.attr("fill", d => colourScale(d[1].length))
								.attr("stroke", "none")
								.attr("opacity", 1)
								.on("mouseover", function(event, d) {
																// console.log("d",d,"this",this); //OK. d is data bind to rect. this is <rect>. 
																d3.select(".tooltip")
																	.selectAll("text")
																	.attr("font-size", t => (t[0] == d[0]) ? 12 : 0)
																	.attr("opacity",  t => (t[0] == d[0]) ? 1 : 0); // t is data bind to text.
																	// .attr("transform", `translate(${margin.left}, ${margin.top})`); // no need to transfer just THE required tip. when I used fontsize = 0 :)

																d3.select(this)
																	.attr("fill", "CornflowerBlue"); //.attr("stroke", "FireBrick"); this does not look nice because of crispEdges.
																	


								})
								.on("mouseout", function(event, d) {
																d3.select(".tooltip")
																	.selectAll("text")
																	// .attr("transform", (this.getAttribute("opacity") == 1) ? `translate(-${margin.left}, -${margin.top})` : "") // no need to transfer back  THE shown tip. when I used fontsize = 0 :)
															   		.attr("font-size", 0)
																	.attr("opacity", 0);

																d3.select(this)
																	.attr("fill" , d => colourScale(d[1].length));	//.attr("stroke", "none");

								})
								.on("click", function(event, d) {
															keyData = d[1];
															keyWords(keyData); 
								});
					
					// Tooltips
					heatmapChart.append("g")
								.attr("class", "tooltip")
								.attr("transform", `translate(${margin.left}, ${margin.top - yAlphabetScale.bandwidth()/2})`)
								.selectAll("text")
								.data(heatmapData)
								.join("text")
								.text(d => `${d[1].length} [ ${d[0][0]} ][ ${d[0][1]} ]`)  // (d[1].length == 1) ? `only ${d[1].length} word starts with ${d[0][0].toUpperCase()} and ends in ${d[0][1].toUpperCase()}` : `${d[1].length} words start with ${d[0][0].toUpperCase()} and end in ${d[0][1].toUpperCase()}`)  
								.attr("x", d => xAlphabetScale(d[0][1]))
						      	.attr("y", d => yAlphabetScale(d[0][0]))
						   		.attr("font-size", 0) //deliberately fontsize=0. to have a 0x0 .tooltip. so it won't cover up the rects preventing mouseover on them!!!!!!!
						   		.attr("font-weight", "300")
						   		.attr("text-anchor", "start")
						   		.attr("fill", "DarkSlateGray")
						   		.attr("opacity", 0);
								

					
								

					// Axis my style
					xAxisHeatMap = d3.axisBottom(xAlphabetScale)
										.tickValues(xAlphabetScale.domain())
										.tickSizeInner(0)
										.tickSizeOuter(0)
										.tickPadding(8) // 8 = 2/3*12(leading)

									

					heatmapChart.append("g")
								.attr("class", "xAxis")
								.attr("transform", `translate(${margin.left}, ${heatMapHeight+margin.top})`)
								.call(xAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey");

					heatmapChart.select(".xAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", xAlphabetScale.range()[1])
						        .attr("y", margin.bottom/2+12) // 12 = the leading for fontsize 10. (1.2*10=12)
						        .attr("fill", "grey")
						        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
						        .attr("font-weight", "300")
						        .attr("text-anchor", "end")
						        .text("LAST LETTER");


			        yAxisHeatMap = d3.axisLeft(yAlphabetScale)
							.tickValues(yAlphabetScale.domain())
							.tickSizeInner(0)
							.tickSizeOuter(0)
							.tickPadding(8);

					heatmapChart.append("g")
								.attr("class", "yAxis")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.call(yAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey")
								.select("path")
								.attr("stroke-opacity", 0.5);;

					heatmapChart.select(".yAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", 0)
						        .attr("y", yAlphabetScale.range()[1]-10)
						        .attr("fill", "grey")
						        .attr("font-size", "10")
						        .attr("font-weight", "300")
						        .attr("text-anchor", "middle")
						        .text("WORD")
						        .text("FIRST LETTER");
					
				};
				
				drawHeatMap(mainWords);


/////////// Draw Flower

				const flowerChart = flower.append("svg")
										.classed("flower", true)
										.attr("viewBox", [0, 0, flowerWidth + margin.left + margin.right , flowerHeight + margin.top + margin.bottom]);
				
				
				function drawFlower(inputData, permission) {
					words = filterbyLength(inputData, d3.max(inputData, w => w.length));
					generateFlower(words, permission);
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ;

					// console.log("valueExtent", d3.extent(flowerValues, g => g[1])); //OK


					flowerScale = d3.scaleLinear()
									.domain(d3.extent(flowerValues, g => g[1]))
									.range(["LightSeaGreen", "SeaGreen"]);
					strokeScale = d3.scaleLinear()
									.domain(d3.extent(flowerValues, g => g[1]))
									.range([0.3, 1]);

					letterScale = d3.scaleOrdinal()
									.domain(vowels, consonents)
									.range(["SpringGreen", "Coral"]);


					
					// Links
				    flowerChart.append("g")
							    .attr("class", "flowerLinks")
								.attr("transform", "translate(" + (margin.left + flowerWidth/2) + "," + (margin.top + flowerWidth/2) + ")")
							    .selectAll("path")
							    .data(data.links)
							    .join("path")
							    .attr("d", flowerLink)
							    .attr("fill", "none")
							    .attr("stroke", d => flowerScale(flowerValues.get(d.sourceKey+d.targetKey)))
							    .attr("stroke-width", d => strokeScale(flowerValues.get(d.sourceKey+d.targetKey))) //if you want to encode link values with width, generally use d => Math.min(1, d.width) or for our case d => values.get(d.source.name+d.target.name) instead of d.width.
							    .attr("stroke-opacity", 0.3)
								.append("title")
							    .text(d => `${d.source.key} → ${d.target.key} \n ${flowerValues.get(d.sourceKey+d.targetKey)}`);

					// Nodes
					flowerChart.append("g")
								.attr("class", "flowerNodes")
								.attr("transform", "translate(" + (margin.left + flowerWidth/2) + "," + (margin.top + flowerWidth/2) + ")")
						    	.selectAll("circle")
						    	.data(realnodes)
						    	.join("circle")
						     	.attr("cx", d => d.cx)
						      	.attr("cy", d => d.cy)
						      	.attr("r", d => r)
						      	.attr("fill", d => letterScale(d.name.match(/\w/)))
						    	.append("title")
						    	.text(d => `${d.key}\n${d.code}`);

				};

				drawFlower(mainWords);


				// d3.select("#flower")
				// 	.on("click", function(event, div){
				// 			d3.select("#flower")
				// 				.attr("grid-area", "1 / 1 / 2 / 31");
				// 			flowerChart
				// 				.attr("width", `${width-margin.left-margin.right}`)
				// 				.attr("height", `${height-margin.top-margin.bottom}`)
				// 				.attr("fill", "white");
				// });


/////////// Toolbar

			

				// Slider change
				function sliderUpdate(lengthLimit) {

					d3.select("#wordLength")
						.node()
						.setAttribute("value", lengthLimit);

       				// d3.select("#wordLength")
						// .clone();
						
					// d3.select("#wordLength")
					// 	.remove();


					d3.select("#slider")
						.select("span")
						.text(lengthLimit);

					
					sankeyChart.select(".nodes").remove();
					sankeyChart.select(".links").remove();
					d3.select(".nodesLabel").remove();
					d3.select(".axis").remove();
					d3.select(".words").remove();
					d3.select(".keyWords").remove();
					

					words = filterbyLength(mainWords, lengthLimit);
					console.log("words on slider change", words);
					generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
					drawSankey(words, false); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.


					d3.select("#output")
						.select("span")
						.text(words.length);
				};

				d3.select("#wordLength")
					.on("click", function() {
											lengthLimit = this.value;
											sliderUpdate(lengthLimit);
										});



				//Buttons

				d3.select("#reset")
					.select(".button")
					.on("click", function() {

										lengthLimit = d3.max(mainWords, w => w.length);
										sliderUpdate(lengthLimit);

										sankeyChart.select(".nodes").remove();
			      						sankeyChart.select(".links").remove();
										d3.select(".nodesLabel").remove();
										d3.select(".axis").remove();
										d3.select(".words").remove();
										d3.select(".keyWords").remove();

										words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));
			      						generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
			      						drawSankey(words, false);
			      						// set slider intial value to max length of the whole dataset
										// permissionNode=false;
										// permissionLink=false;


									});


				d3.select("#list")
					.select(".button")
					.on("click", function() {
									// console.log("nextFilteredData in download scope", nextFilteredData); //OK
									conent = nextFilteredData;
									header = "data:text/plain;charset=utf-8,"
									payload = header + encodeURIComponent(conent);

									this.href = payload;
								});



				






			  // alert("done");
			

			}); // this is the END of .then(function(rawdata) {...  after loading data :)


		</script>
		

	</body>
</html>
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Darya-Yarparvar__Graphic Designer</title>
		<meta name="description" content="Darya Yarparvar * Graphic Designer * Birmingham, UK * Open to work! ** Please visit my personal website and view my works. ** I would be more than happy to be of any help to your creative projects! **">
		<meta name="author" content="© 2021 Darya Yarparvar. All rights reserved.">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

		<link rel="preconnect" href="https://use.typekit.net/mok3rgv.css">
		
		
		<link rel="stylesheet" type="text/css" href="css/style.css">


		<link rel="stylesheet" type="text/css" href="css/icon-style.css">
		<link rel="stylesheet" href="https://use.typekit.net/mok3rgv.css">


		<base target="_blank">



        <script type="text/javascript" src="js/d3.js"></script>
        <script type="text/javascript" src="js/d3-sankey.js"></script>
       
       	
	</head>
	<body>
		
		
		<div id="wrapper">
			<div id="container">
				
				<div id="context">
					<h1 id="title">Copy Text Signature</h1>
				</div>
				
				
				<div id="graphics">
					<!-- <div id="control-panel"></div> -->
					<!-- <div id="chart"></div> -->
				</div>
			</div>
			
			
		</div>

<!--
*****************************
****************************
***************************
************************** Data Visualisation Code __ START 
***************************
****************************
******************************
-->


		<script type="text/javascript">
			
// Settings (Width and height) from outside to inside

			

			var width = screen.availWidth,
				height = screen.availHeight,

				padding = {top: 60, right: 60, bottom: 60, left: 60},
				margin = {top: 20, right: 20, bottom: 30, left: 40};

			

// Load in raw data & THEN...
			d3.json("data/words_dictionary-test.json").then(function(rawdata) {  //I deleted "jean-christophe": 1, from data. due to - character.
				// console.log(rawdata); //OK

				const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
				const vowels = ["a","e","i","o","u"];
				const consonents = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"];

	//Read data
				var words = Object.keys(rawdata);
				console.log("words", words); //OK	

	//Data wrangling

			

				var sankeyHeight = height*1.2;

				




				function prepareData(inputData) {

					console.log("inputData in prepareData scope",inputData);


					// the length of the longest word	
					var L = d3.max(inputData, w => w.length);
					console.log("max word length", L); //OK

					// Nodes
					var nodes = [];
					d3.map(alphabet, letter => { for (let i=1; i<=L; i++) {
													nodes.push({
																name: letter+i,
															});
													}
												});
					console.log("nodes", nodes); //OK

				    // Links
					var links = [];

					var letterByletter = d3.map(inputData, w => Array.from(w));
					d3.map(letterByletter, array => { for (let i=0; i<array.length-1; i++) {
														links.push({
															word : array.join(""),
															source : array[i]+(i+1),
															target : array[(i+1)]+(i+2),
															value : 1,
															});
														}
													});
					console.log("links", links); //OK

					values = d3.rollup(links, g => g.length, obj => obj.source+obj.target);
					console.log("values", values); //OK

					// Data for Sankey
					var data = {
								nodes : nodes.map(d => Object.assign({}, d)),
								links : links.map(d => Object.assign({}, d))
							};
					console.log("data in prepareData scope", data); //OK

					return {data : data,
							L : L} ;
					

				};

				
				
				function highlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 1 : 0.5)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSalmon" : "DarkSeaGreen");
				};

				function unhighlightAdjLinks(node) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  path => (path.source.index == node.index || path.target.index == node.index) ? 0.5 : 0.5)
						.attr("stroke", path => (path.source.index == node.index || path.target.index == node.index) ? "DarkSeaGreen" : "DarkSeaGreen");
				};


				function highlightNodes(node1,node2) {
				    d3.select(".nodes")
						.selectAll("rect")
						.attr("fill", rect => (rect.index == node1 || rect.index == node2) ? "navy" : "white");
				};





				// var prevFilteredData = d3.map(words, w => w);

				function filter(inputData,node, prevFilteredData) {
			
					// if (prevFilteredData.length == 0) {
					// 						prevFilteredData = d3.map(inputData, w => w);
					// 					};
					nextFilteredData = d3.filter(prevFilteredData, w => (w[(node.depth+1)-1] == node.name.match(/\w/)));
					console.log("prevFilteredData in filter scope", prevFilteredData); //OK
					console.log("nextFilteredData in filter scope", nextFilteredData); //OK
					return nextFilteredData;
				};

			

			// Sankey generator

				function generateSankey(inputData) {   //better to use prepareData inside this function. data still will be available at global scope. and you have control on updating sankey generator based on filtered data.
					
					// console.log("data in generateSankey scope", data); //here data is not defined yet. and so not L.
					data = prepareData(inputData).data;
					L = prepareData(inputData).L; //the first time you are gonna define data. data will be at global scope.
					console.log("data in generateSankey scope", data); // OK.  here data is defined. and so is L :)
					console.log("L in generateSankey scope", L); // OK.  here data is defined. and so is L :)

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodeWidth((((width-margin.left-margin.right)/L)/10))
						      	.nodePadding(0)
						      	.nodeSort(d3.descending) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    // .linkSort(null)
						      	.extent([[10,10], [width - 10, sankeyHeight - 10]]);

						      	// .nodes(nodes.map(d => Object.assign({}, d))) // you can also determine nodes & links of the d3.sankey at this step. or give both of the arguments as data {nodes: , links: } format. like sankey(data). 
						      	// .links(links.map(d => Object.assign({}, d)));
					

					
					sankey(data);


					d3.map(data.nodes, node => { 
											node.x0 = (node.depth+1)*((width-margin.left-margin.right)/L);
											node.x1 = node.x0+(((width-margin.left-margin.right)/L)/10);
											}
									);
				}


				generateSankey(words);
				

				

			// Create Chart
				const graphics = d3.select("#graphics");
				const sankeyChart = graphics.append("svg")
										.classed("sankey", true)
										.attr("viewBox", [0, 0, width, sankeyHeight]); //width*1.5
				
				
				function drawSankey(inputData, permission) {

					console.log("data in drawSankey scope", data); //OK
					// data = prepareData(words); //somehow this line causes an error. I could not figure out why!? Maybe because its already defined?!?!
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ; //here if any of nodes has been already clicked the nextFilterData wont be reset to words :) so consecutive clicking will result in step by step filtering and selection of words based on each clicked node & ultimately shrinking the inputData :)

					sankeyChart.append("g")
								.attr("class", "nodes")
						    	.selectAll("rect")
						    	.data(data.nodes)
						    	.join("rect")
						     	.attr("x", d => d.x0)
						      	.attr("y", d => d.y0)
						      	.attr("height", d => d.y1 - d.y0) //if svg height is not high enough, y0 & y1 for small values will be equal & rect height = zero. :|
						      	.attr("width", d => d.x1 - d.x0)
						      	.attr("fill", "white")
						      	.attr("stroke", "navy")
						      	.on("mouseover", function(event, node) {
						      						d3.select(this) //"this" is each <rect>
						      							.attr("fill", "navy")
						      						highlightAdjLinks(node); //node as the second input of a function applied on an event is directly the bind data itself.

										      	})
						      	.on("mouseout", function(event, node){
						      						d3.select(this)
						      							.attr("fill", "white");

						      						// unhighlightAdjLinks(node);
						      									
										      	})
						      	.on("click", function (event, node) {
						      						permission = true; //when permission is true, it means a node has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
													var prevFilteredData = nextFilteredData;
						      						nextFilteredData = filter(inputData,node,prevFilteredData);
						      						sankeyChart.select(".nodes").remove();
						      						sankeyChart.select(".links").remove();
						      						generateSankey(nextFilteredData); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
						      						drawSankey(nextFilteredData, permission); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
						      						

						      						console.log("data on click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
						      						console.log("prevFilteredData on click", prevFilteredData); //OK
													console.log("nextFilteredData on click", nextFilteredData); //OK
						      						highlightAdjLinks(node);
												      		
												      	})
						    	.append("title")
						    	.text(d => `${d.name}\n${d.value}`); // d.name.match((/\w/))

						    sankeyChart.append("g")
							    .attr("class", "links")
							    .attr("fill", "none")
							    .attr("stroke", "DarkSeaGreen")
							    .selectAll("path")
							    .data(data.links)
							    .join("path")
							    .attr("d", d3.sankeyLinkHorizontal())
							    .attr("stroke-width", 1) //if you want to encode link values with width, generally use d => Math.min(1, d.width) or for our case d => values.get(d.source.name+d.target.name) instead of d.width.
							    .attr("stroke-opacity", 0.5)
							    .on("mouseover", function(event, node) { 
													    	d3.select(this)
													    		.attr("stroke", (this.getAttribute("stroke")=="DarkSalmon") ? "red" : "navy")
													    		.attr("stroke-opacity", 1);

													    	index1 = node.source.index;
													    	index2 = node.target.index;	
													    	highlightNodes(index1,index2);



														})
							    .on("mouseout", function(event, node) { 
													    	d3.select(this).attr("stroke", (this.getAttribute("stroke")=="red") ? "DarkSalmon" : "DarkSeaGreen")
													    	.attr("stroke-opacity", (this.getAttribute("stroke")=="DarkSalmon") ? 1 : 0.5);

													    	d3.select(".nodes")
																.selectAll("rect")
																.attr("fill", "white");


													    })
								.append("title")
							    .text(d => `${d.source.name} → ${d.target.name}\n${values.get(d.source.name+d.target.name)}`)

				}



				console.log("data in global scope", data); //OK
				drawSankey(data); // with or without this inputdata = data,  drawSankey works. define it with no input & give it no input. OR define it with inpit & give it data as input. Both are the same.




				


				






			  // alert("done");
			});


		</script>
		

	</body>
</html>
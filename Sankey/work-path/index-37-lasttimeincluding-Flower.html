<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
		<title>Darya-Yarparvar__Graphic Designer</title>
		<meta name="description" content="Darya Yarparvar * Graphic Designer * Birmingham, UK * Open to work! ** Please visit my personal website and view my works. ** I would be more than happy to be of any help to your creative projects! **">
		<meta name="author" content="Â© 2021 Darya Yarparvar. All rights reserved.">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

		<link rel="preconnect" href="https://use.typekit.net/mok3rgv.css">
		
		
		<link rel="stylesheet" type="text/css" href="css/style.css">


		<link rel="stylesheet" type="text/css" href="css/icon-style.css">
		<link rel="stylesheet" href="https://use.typekit.net/mok3rgv.css">


		<base target="_blank">



        <script type="text/javascript" src="js/d3.js"></script>
        <script type="text/javascript" src="js/d3-sankey.js"></script>
       	
	</head>
	<body>
		
		
		<div id="wrapper">
			<div id="container" class="grid">
				
				<div id="flower">
					<h1>Word List Flower</h1>
					
				</div>

				<div id="context">
					<h1 id="heading">Scrabble Sankey</h1>
					<h3 id="intro">I could not resist choosing a playful subject to practice Sankey diagram... and I love word games! So here it is: <em>the scrabble sankey</em>! Play with it and have fun!</h3>
					<p><br><br>Words are strings of letters (spread horizontally). Each node represents a letter at a specific position. Each link connects two adjacent letters of a word.<br><br>This Sankey diagram is a multilevel network idiom that combines a node-link diagram with a derived cluster hirearchy, intending the path tracing as the main desired task.</p>
				</div>
					
				<div id="userGuide">
					<h2>How to use this visualisation:</h2>	
					<p>First, set the upper limit for words' length using the slider (the default is set to the longest word in the dataset).<br><br>Click on a node to narrow down the current word list to those words that have the selected letter at the selected position.<br><br>Click on a link to narrow down the current word list to those words that have the selected consecutive letters at those specific positions.<br><br>If you click on the slider without changing its value, the word list filteration caused by clicking node/link will be reset to none.<br><br>You can download the list of the words at whatever step you like :)</p>
				</div>
					
				
				<!-- <div id="legend">
						<h3>How to read the chart</h3>	
				</div> -->



				<div id="slider">
				  	<label for="wordLength">Set the word length limit</label>
					<input type="range" min="1" max="31" value="10" id="wordLength">
				</div>

				<div id="output">
					<h3>How many words?</h3>
					<span></span>
				</div>

				<div id="special">
					<a href="">*</a>
					<a href="">*</a>

				</div>


				<div id="reset">
					<a class="button">Reset</a>
				</div>

			  	<div id="list">
					<a href="" download="selected-word-list.txt" class="button">Download</a>
				</div>


				<div id="graphics" class="grid">

				</div>


				<!-- <div id="file">
				  	<label for="dataFile">You can upload your own word list [in .txt format] & play with the diagram! </label>
					<input type="file" name="loadData" id="dataFile">
				</div> -->


				<div id="footnotes">
						<h2>footnotes & methods</h2>	
				</div>



					
			</div>
				


				
				
				




				



			</div>
			
			
		</div>

<!--
*****************************
****************************
***************************
************************** Data Visualisation Code __ START 
***************************
****************************
******************************
-->


		<script type="text/javascript">
			
/////// Settings (width, height, margin,)

			

			var width = screen.availWidth,
				height = screen.availHeight,

			padding = {top: 60, right: 60, bottom: 60, left: 60},
			margin = {top: 60, right: 50, bottom: 60, left: 50};
			deltaAxis = 40;

			// margin = {top: 150, right: 50, bottom: 100, left: 250}; //trial

			const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
			const vowels = ["a","e","i","o","u"];
			const consonents = ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"];

			const colours = ["#7e1900","#801c01","#811f02","#822203","#832504","#852705","#862a06","#872d06","#882f07","#8a3108","#8b3409","#8c360a","#8d380b","#8e3b0c","#8f3d0c","#903f0d","#92410e","#93440f","#944610","#954811","#964a12","#974c13","#984e14","#995015","#9a5315","#9b5516","#9c5717","#9d5918","#9e5b19","#9f5d1a","#a05f1b","#a1611c","#a2631c","#a3651d","#a4671e","#a5691f","#a66b20","#a76d21","#a86f21","#a97122","#aa7323","#ab7524","#ac7725","#ad7926","#ae7c27","#af7e27","#b08028","#b18229","#b2842a","#b3862b","#b4882c","#b58a2d","#b68c2e","#b78e2e","#b8902f","#b99230","#ba9431","#bb9632","#bc9933","#bd9b35","#be9d36","#bf9f37","#c0a138","#c1a339","#c2a63b","#c3a83c","#c4aa3e","#c6ac3f","#c7af41","#c8b143","#c9b344","#cab646","#cbb848","#cdba4a","#cebc4d","#cfbf4f","#d0c151","#d2c354","#d3c556","#d4c859","#d5ca5c","#d6cc5e","#d8ce61","#d9d064","#dad267","#dbd36a","#dcd56c","#ddd76f","#ded872","#dfda75","#e0db78","#e0dc7b","#e1de7e","#e2df80","#e3e083","#e3e186","#e4e289","#e4e38b","#e5e48e","#e5e590","#e5e593","#e6e695","#e6e798","#e6e79a","#e6e89d","#e6e89f","#e6e9a1","#e6e9a4","#e6eaa6","#e6eaa8","#e6ebaa","#e5ebad","#e5ebaf","#e4ecb1","#e4ecb3","#e3ecb5","#e2ecb7","#e1edb9","#e0edba","#dfedbc","#deedbe","#ddedc0","#dbedc1","#daeec3","#d8eec4","#d7eec6","#d5eec7","#d3eec9","#d1edca","#cfedcb","#cdedcc","#cbedcd","#c9edcf","#c6edd0","#c4ecd1","#c1ecd1","#bfecd2","#bcebd3","#b9ebd4","#b7ead5","#b4ead5","#b1e9d6","#aee9d7","#abe8d7","#a8e7d8","#a5e7d8","#a2e6d9","#9fe5d9","#9ce4d9","#99e3da","#96e2da","#93e1da","#90e0da","#8ddfda","#8addda","#87dcdb","#84dbda","#81d9da","#7ed8da","#7bd6da","#78d5da","#75d3da","#73d1d9","#70d0d9","#6eced9","#6bccd8","#69cad8","#67c9d7","#65c7d7","#63c5d6","#61c3d6","#5fc1d5","#5ebfd4","#5cbed4","#5abcd3","#59bad2","#58b8d2","#56b6d1","#55b4d0","#54b2d0","#53b0cf","#52afce","#50adcd","#4fabcd","#4ea9cc","#4da7cb","#4da5ca","#4ca4ca","#4ba2c9","#4aa0c8","#499ec7","#489cc7","#479ac6","#4799c5","#4697c4","#4595c3","#4493c3","#4492c2","#4390c1","#428ec0","#418cc0","#418abf","#4089be","#3f87bd","#3e85bd","#3e84bc","#3d82bb","#3c80bb","#3c7eba","#3b7db9","#3a7bb8","#3979b8","#3978b7","#3876b6","#3774b5","#3773b5","#3671b4","#356fb3","#356eb3","#346cb2","#336ab1","#3369b0","#3267b0","#3165af","#3164ae","#3062ae","#2f61ad","#2f5fac","#2e5dac","#2d5cab","#2d5aaa","#2c59a9","#2b57a9","#2b55a8","#2a54a7","#2952a7","#2951a6","#284fa5","#274da5","#274ca4","#264aa3","#2549a3","#2547a2","#2446a1","#2344a1","#2342a0","#22419f","#213f9f","#203e9e","#1f3c9d","#1f3b9c","#1e399c","#1d379b","#1c369a","#1b349a","#1a3399"];

/////// Load & Read data
			
	/////// OPTION 1 : Load in raw JSON data & THEN...
			// d3.json("data/words_dictionary.json").then(function(rawdata) {  //I deleted "jean-christophe": 1, from data. due to - character.
			// 	// console.log(rawdata); //OK
			// 	// mainWords = d3.csvParseRows(rawdata, line => line.toString());
			// 	var mainWords = [...d3.difference(Object.keys(rawdata),alphabet)]; //exclude alphabet because they are single letters & no node/link meaning.
			// 	console.log("mainWords", mainWords); //OK	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/////// OPTION 2 : Load in raw TEXT data & THEN...
			d3.text("data/list.txt").then(function(rawdata) {
				// console.log(rawdata); //OK
				mainWords = [...d3.difference(d3.csvParseRows(rawdata, line => line.toString().toLowerCase()),alphabet)]; // I deleted "won't" & "don't"

				console.log("mainWords", mainWords); //OK	 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////// Initiation

				
				// the length of the longest word	
				// L = d3.max(mainWords, w => w.length);   //if you define L outside prepareData function by using mainWord instead of inputdata of prepareData & use L instead of d3.max(mainWords, w => w.length) in this part : words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));, then L will be fixed to max length of mainWords & the placement of nodes wont be updated by interactivity at prepareData step and then at generateSakey steps.
				// console.log("max word length", L); //OK
				

				
				// Slider settings
				// set slider intial value to max length of the whole dataset
				d3.select("#wordLength")
					.node()
					.setAttribute("max", d3.max(mainWords, w => w.length));
				d3.select("#wordLength")
					.node()
					.setAttribute("value", d3.max(mainWords, w => w.length));

				d3.select("#slider")
					.append("span")
					.text(d3.select("#wordLength").node().value);

				// Output
				d3.select("#output")
					.select("span")
					.text(mainWords.length);



/////////// Sankey Data Preperation
				function prepareData(inputData) {

					console.log("inputData in prepareData scope", inputData); //OK

					
					//the length of the longest word	
					L = d3.max(inputData, w => w.length);
					console.log("max word length", L); //OK
					

					// Nodes
					nodesSet = new Set(); //nodes won't be redundent. (but why links are so?! :( )
					d3.map(inputData, word => { for (let i=0; i<word.length; i++) {
														nodesSet.add(word[i]+(i+1));
													}
												});

					nodes = d3.map(nodesSet, n => { return {
															name: n // word[i]+(i+1)
														}
													});

					console.log("nodes", nodes); //OK


				    //Links
					
					linksSet = new Set();
					d3.map(inputData, word => { for (let i=0; i<word.length-1; i++) {
														linksSet.add([word[i]+(i+1), word[(i+1)]+(i+2), word]);
													}
												});

					links = d3.map(linksSet, l => { return { 
															source : l[0], // word[i]+(i+1)
															target : l[1], //word[(i+1)]+(i+2)
															word : l[2]
														}
													});


					values = d3.rollup(links, g => g.length, l => l.source+l.target);
					console.log("values", values); //OK


					linkGroups = d3.flatGroup(links, l => l.source, l => l.target);
					console.log("linkGroups", linkGroups); //OK

					// to get rid of redundency in links
					links = d3.map(linkGroups, g => { return { 
																source : g[0],
																target : g[1],
																value : values.get(g[0]+g[1]) //or g[2].length :)
																}
																		
													});
					console.log("links", links); //OK



					// Data for Sankey
					var data = {
								nodes : nodes.map(d => Object.assign({}, d)),
								links : links.map(d => Object.assign({}, d))
							};
					console.log("data in prepareData scope", data); //OK

					return {data : data,
							L : L} ;
				};


/////////// Flower Data Preperation
				function prepareFlowerData(inputData) {
					L = d3.max(inputData, w => w.length);



					// options for sorting data
					// inputData.sort((w1, w2) => d3.descending(w1.length, w2.length));
					// inputData.sort( (w1, w2) => (w2[0]- w1[0]) || (w2.length- w1.length) );



					// all words will be shown as radial lines in a concenteric circles. so you should somehow combine word (as a specific key) with your node (for example e3 / bread) to make it different than the similar nodes (for example e3 / crew).

					// Nodes
					flowerNodes = [];
					d3.map(inputData, word => { for (let i=0; i<word.length; i++) {
														flowerNodes.push( [  word[i]+(i+1)   ,  word[i]+(i+1) + "/" + word   , word ]);
													}
												});

					flowerNodes = d3.map(flowerNodes, n => { return {
														key: n[0], // word[i]+(i+1)
														name: n[1], // word[i]+(i+1) + "/" + word
														code: n[2] // word
														}
											});


					console.log("flowerNodes", flowerNodes); //OK

				    // Links
					flowerLinks = [];

					d3.map(inputData, word => { for (let i=0; i<word.length-1; i++) {
														flowerLinks.push([ word[i]+(i+1) + "/" + word  , word[(i+1)]+(i+2) + "/" + word , word[i]+(i+1)  , word[(i+1)]+(i+2)  ]);
													}
												});

					flowerLinks = d3.map(flowerLinks, l => { return { 
																	source : l[0], // word[i]+(i+1) + "/" + word 
																	target : l[1], // word[(i+1)]+(i+2) + "/" + word
																	sourceKey: l[2], // word[i]+(i+1)
																	targetKey: l[3], // word[(i+1)]+(i+2)
																	}
															});

					flowerValues = d3.rollup(flowerLinks, g => g.length, obj => (obj.sourceKey) + (obj.targetKey));
					console.log("flowerValues", flowerValues); //OK

					flowerLinks = d3.map(flowerLinks, l => { return { 
														source : l.source,
														target : l.target,
														sourceKey: l.sourceKey,
														targetKey: l.targetKey,
														value: values.get(l.sourceKey+l.targetKey)
													}
												});

					console.log("flowerLinks", flowerLinks); //OK

					// Data for Flower
					var flowerData = {
								nodes : flowerNodes.map(d => Object.assign({}, d)),
								links : flowerLinks.map(d => Object.assign({}, d))
							};
					console.log("flowerData in flowerData scope", flowerData); //OK

					return {data : flowerData,
							L : L} ;
				};



/////////// HeatMap Data Preparation
				function heatmapInfo(inputData) {
					heatmapData = d3.flatGroup(inputData, w => w[0]+w[w.length-1]);
					return heatmapData;
				};
				console.log("heatmapData", heatmapInfo(mainWords)); //OK



/////////// Interactivity
				
			generalTransition = d3.transition()
								.duration(300)
								.delay(3000)
							    .ease(d3.easeLinear);

			// linkTransition = d3.select(".links")
			// 					.selectAll("path")
			// 					.transition();

			// nodeTransition = d3.select(".nodes")
			// 					.selectAll("rect")
			// 					.transition();

			// tooltipTransition = d3.select(".tooltip")
			// 					.selectAll("text")
			// 					.transition();


			// function color(transition, fill, stroke) {
			//   transition
			//       .style("fill", fill)
			//       .style("stroke", stroke);
			// }

			// color(linkTransition, "red", "blue");



			// linkTransition.duration(500)
			// 				.delay(function(d, i) { return i * 10; })
			// 				.ease()
			// 				.on("start", function(event, d) {
			// 					paths.classed("unclickable", true); 
			// 				})
			// 				.duration(300)
			// 				.on("end", function(event, d) {
			// 					paths.classed("unclickable", true); 
			// 				})
			// 				.style("" , "")
			// 				.attr("fill", "black")


			// 				.on("interrupt", function(event, d) {
			// 					paths.classed("unclickable", true); 
			// 				})
			// 				.on("cancel", function(event, d) {
			// 					paths.classed("unclickable", true); 
			// 				})

					// .transition()
				 //    .styleTween("color", function() { return d3.interpolate("green", "red"); });

				// .on("start", function repeat() {
				// 						        d3.active(this)
				// 						            .styleTween("background-color", function() { return whiteblue; })
				// 							        .transition()
				// 						            .delay(1000)
				// 						            .styleTween("background-color", function() { return blueorange; })
				// 						            .transition()
				// 						            .delay(1000)
				// 						            .styleTween("background-color", function() { return orangewhite; })
				// 						            .transition()
				// 						            .delay(n)
				// 						            .on("start", repeat);
				// 					      });


				time = 100;
				function delay(d, i) { return i * 10; };


				function highlightAdjLinks(n) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  p => (p.source.name == n.name || p.target.name == n.name) ? 1 : opacityScale(p.value))
						.attr("stroke", p => (p.source.name == n.name || p.target.name == n.name) ? "DarkSalmon" : "DarkSeaGreen");


				};

				function unhighlightAdjLinks(n) {
				    d3.select(".links")
						.selectAll("path")
						.attr("stroke-opacity",  p => (p.source.name == n.name || p.target.name == n.name) ? opacityScale(p.value) : opacityScale(p.value))
						.attr("stroke", p => (p.source.name == n.name || p.target.name == n.name) ? "DarkSeaGreen" : "DarkSeaGreen");
				};


				function highlightNodes(n1, n2) {
				    d3.select(".nodes")
						.selectAll("rect")
						.attr("fill", r => (r.name == n1.name || r.name == n2.name) ? "navy" : "white");
				};


				// replace this with d3.raise() !!!!
				// https://github.com/wbkd/d3-extended
			    function moveToFront(link) { 
			    	return link.parentNode.appendChild(link);
			    	
			    };

				// replace this with d3.lower() !!!!
			    // https://github.com/wbkd/d3-extended
			    function moveToBack(link) { 
			    	firstChild = link.parentNode.firstChild;
			    	if (firstChild) { 
			                return link.parentNode.insertBefore(link, firstChild); 
			            };
			    };


				function filterbyNL(inputData, n, filteredData) {
					nextFilteredData = d3.filter(filteredData, w => (w[(n.depth+1)-1] == n.name.match(/\w/)));
					console.log("prevFilteredData in filter scope", filteredData); //OK
					console.log("nextFilteredData in filter scope", nextFilteredData); //OK
					return nextFilteredData;
				};


				function filterbyLength(inputData, lengthLimit) {
					limitedData = d3.filter(inputData, w => (w.length <= lengthLimit));
					console.log("limitedData in filterbyLength scope", limitedData); //OK
					return limitedData;
				};


				// Word emerge !
				function wordList(filteredData) {
					if (filteredData.length <= 10) {
						if (!graphics.select(".words").node()) {  
							graphics.append("g")
									.attr("transform", `translate(${margin.left}, ${margin.top})`)
									.attr("class", "words")
									.selectAll("text")
									.data(filteredData)
									.join("text")
									.text(d => d)

							} else {
							graphics.select(".words")
									.selectAll("text")
									.data(filteredData)
									.join("text")
									.text(d => d)
						}
					};
				};



				// words starting with this letter:
				function startLetter(inputData,letter) {
					(!letter) ? letter = w[0] : letter = letter.toString();
					return d3.group(inputData, w => w[0]).get(letter);
				};
				// console.log("words starting with this Letter", startLetter(mainWords, "c")); //OK //for example all the words starting with c.
				
				// words ending with this letter:
				function endLetter(inputData,letter) {
					(!letter) ? letter = w[w.length-1] : letter = letter.toString();
					return d3.group(inputData, w => w[w.length-1]).get(letter);
				};
				// console.log("words ending with this Letter", endLetter(mainWords, "c")); //OK //for example all the words ending with c.
				
				
				// Word Key
				function keyWords(keyData) {
					if (!graphics.select(".keyWords").node()) {  //if there's no .keyWords already made, first make one & the append <text>s & ...
						graphics.append("g")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.attr("class", "keyWords")
								.selectAll("text")
								.data(keyData)
								.join("text")
								.text(d => d)

						} else {  //if .keyWords has already been made, just append <text>s & ...
						graphics.select(".keyWords")
								.selectAll("text")
								.data(keyData)
								.join("text")
								.text(d => d)
					};

					// unsuccessful setting for height of .keyWords :(  must ork on it. for now I set the max-height to 400 at style.css
					// grid = d3.select("#graphics").node();
					// gridStyle = getComputedStyle(grid);
					// h = gridStyle.getPropertyValue("grid-template-rows");
					// console.log("h", h);
					// d3.select(".keyWords")
					// 	.attr("height", h[1]);
					
				};


/////////// Sankey Generator
				var sankeyHeight = 660 - margin.top - margin.bottom - deltaAxis; //height*1.2;
				var sankeyWidth = width - margin.left - margin.right;

				function generateSankey(inputData, permission) {   //better to use prepareData inside this function. data still will be available at global scope. and you have control on updating sankey generator based on filtered data.
					
					// console.log("data in generateSankey scope", data); //here data is not defined yet. and so not L.
					data = prepareData(inputData).data;
					L = prepareData(inputData).L; //the first time you are gonna define data. data will be at global scope.
					console.log("data in generateSankey scope", data); // OK.  here data is defined. and so is L :)
					console.log("L in generateSankey scope", L); // OK.  here data is defined. and so is L :)

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodeWidth(((sankeyWidth/(L+1))/3))
						      	.nodePadding(0)
						      	// .nodeSort((node1,node2) => d3.ascending(node1.name, node2.name)) //use null for sort based on input. here I wanted the alphabetic sort for all nodes.
							    .linkSort(d3.descending) // it seems without node sorting the results are better!!!! no node crashing ?!?!?!?!?!?!!?!?!!?!?
						      	.extent([[1,1], [sankeyWidth- 1, sankeyHeight- 1]]);

					sankey(data);

					nodes = data.nodes;
					// its enough to sort the nodes based on the KEY digits (either 2 digits , if null then 1 digit). because you will use this for determinin the x for letter index axis. 
					nodes = nodes.sort((a,b) =>  ((a.name.match(/\d{2}/)|| a.name.match(/\d{1}/)) - (b.name.match(/\d{2}/) || b.name.match(/\d{1}/))) );
					console.log("sorted nodes",nodes); //OK

					// fixing the place of a..z nodes at each position (parallel lines with fixed x , width & distance)
					d3.map(nodes, node => { 
												distance = sankeyWidth/(L+1);
												nodeWidth = distance/3;

												node.x0 = (node.depth+1)*distance-(nodeWidth/2);
												node.x1 = node.x0+nodeWidth;

												
												// console.log("max nodes at any position?"); //OK
												name = node.name.match(/\w/);
												nodeHeight= sankeyHeight/26;
												// // OPTION 1 : this conditional part of code fixes y0,y1,height of the nodes at overview state. at detail state(click on node/link) the height of nodes encodes their value.
												// if (!permission) {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	node.y1 = node.y0 + nodeHeight;
												// }
												// OPTION 2 : this UNconditional part of code fixes y0,y1,height of the nodes at overview & detail states (click on node/link) & the height of nodes NEVER encodes anything & its always constant.
												{
													d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
													node.y1 = node.y0 + nodeHeight;
												} 
												// OPTION 3 : this condition fixes y0,y1,height of the nodes at detail states (click on node/link) & the height of nodes DO STH!!!!!! ?????!??? 
												// else {
												// 	d3.map(alphabet, letter => (name==letter) ? node.y0 = alphabet.indexOf(letter)*nodeHeight : 0);
												// 	// node.y1 = node.y0 + nodeHeight;
												// } 
												
											}
									);

					// fixing the place of links. so all links between two specific nodes are on top of each other. & also each node only encodes the item. and NOT the value. all nodes will have equal length. (fixed y & length)
					d3.map(data.links, link => { 
												link.y0 = (link.source.y0+link.source.y1)/2;
												link.y1 = (link.target.y0+link.target.y1)/2;
											}
									);
					links = data.links;
				};


/////////// Histogram Generator
			  
				function histo(inputData) {
					lengthValues = d3.map(inputData, w => w.length);
					buckets = d3.bin()
								.thresholds(d3.max(inputData, w => w.length));//.thresholds(L) does not gaurantee to recieve L buckets!!! like d3.ticks. 
					// histogram = d3.histogram()
					// 				.thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()); //// you can define your own function .thresholds((w, min, max) => [...new Set(data.map(w => w[0]))].sort()) this example classifies words with respect to their initial letters if the values are inputData=words. 
					// BUT WHY d3.histogram does not work?!?!?!?
					// console.log(buckets.domain()(lengthValues)); //OK by default the domain is the extend of inputData
					return buckets(lengthValues);
				};


/////////// Flower Generator
				var flowerHeight = 660 - margin.top - margin.bottom;
				var flowerWidth = 660 - margin.left - margin.right; //flowerHeight; //width - margin.top - margin.bottom;

				function generateFlower(inputData, permission) {
					wordNumbers = inputData.length;
					data = prepareFlowerData(inputData).data;
					L = prepareFlowerData(inputData).L;

					// Sankey generator
					sankey = d3.sankey()
						    	.nodeId(d => d.name)
						      	.nodeAlign(d3.sankeyJustify)
						      	.nodePadding(0)
						      	.nodeSort(null)
							    .linkSort(null)
						      	.extent([[1,1], [flowerWidth- 1, flowerHeight- 1]]);

					sankey(data);

					nodes = data.nodes;
					// console.log("sorted flowerNodes", nodes);

					// fixing the place of nodes first letter at the inner most layer & last letter on the outer most layer. 
					d3.map(nodes, node => { 
												distance = (flowerWidth/(L+1))/1.5;
												r = distance/40;
												// divide 360deg to the number of words you have.
												phi = 2*Math.PI/wordNumbers;
												// console.log("phi", phi); //OK

												node.radius = (node.name.match(/\d{2}/) || node.name.match(/\d{1}/))*distance - 2*r;

												d3.map(inputData, word => (node.code == word) ? node.angle = inputData.indexOf(word)*phi : 0);

												// the x & y of each point on the circle can be determined knowing the radius & angle.
												node.cx = Math.sin(node.angle)*node.radius ;
												node.cy = Math.cos(node.angle)*node.radius ;											
											}
									);

					// map each link & give it the information for the positions of source and target.
					d3.map(data.links, link => { 
												link.sourcePosition = [link.target.cx, link.target.cy];
												link.targetPosition = [link.source.cx, link.source.cy];
											}
									);
					links = data.links;


					// modify d3.sankeyLinkHorizontal() to get the link information from link.sourcePosition & link.targetPosition keys instead of x0,y0 & x1,y1.
					flowerLinkGenerator = d3.sankeyLinkHorizontal()
								.source(d => d.sourcePosition)
								.target(d => d.targetPosition);
				};



/////////// Graphics
				const graphics = d3.select("#graphics");
				const flower = d3.select("#flower");

/////////// Draw Sankey
				const sankeyChart = graphics.append("svg")
										.classed("sankey", true)
										.attr("viewBox", [0, 0, sankeyWidth + margin.left + margin.right , sankeyHeight + margin.top + margin.bottom + deltaAxis]);
				
				
				function drawSankey(inputData, permission) {
					words = filterbyLength(inputData, d3.max(inputData, w => w.length));
					generateSankey(words, permission);

					console.log("data in drawSankey scope", data); //OK
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ; //here if any of nodes has been already clicked the nextFilterData wont be reset to words :) so consecutive clicking will result in step by step filtering and selection of words based on each clicked node & ultimately shrinking the inputData :)

					opacityScale = d3.scaleLinear()
									.domain(d3.extent(values, g => g[1]))
									.range([0.3, 0.3]);

					strokeScaleSankey = d3.scaleLinear()
									.domain(d3.extent(values, g => g[1]))
									.range([1, nodeHeight]);




					// Links
				    sankeyChart.append("g")
							    .attr("class", "links")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
							    .selectAll("path")
							    .data(links)
							    .join("path")
							    .attr("d", d3.sankeyLinkHorizontal())
							    .attr("fill", "none")
							    .attr("stroke", "DarkSeaGreen")
							    .attr("stroke-width", d => strokeScaleSankey(d.value))
							    .attr("stroke-opacity", d => opacityScale(d.value))
							    .on("mouseover", function(event, link) { 
														    	// move the highlighted link to front:
															   	moveToFront(this);



								    							d3.select(".links")
															   		.selectAll("path")
															   		.attr("stroke", p => ((link.source.name==p.source.name) && (link.target.name==p.target.name)) ? "navy" : "DarkSeaGreen")
															   		.attr("stroke-opacity", p => ((link.source.name==p.source.name) && (link.target.name==p.target.name) )? 1 : opacityScale(p.value));

															   	
														    	node1 = link.source;
														    	node2 = link.target;	
														    	highlightNodes(node1,node2);

														    	d3.select(".nodesLabel")
									      							.append("text")
									      							.attr("class", "temporary")
									      							.text(`${link.source.name.match(/\w/)}`)
									      							.attr("x", (link.source.x0+link.source.x1)/2)
															      	.attr("y", (link.source.y0+link.source.y1)/2 +2)
															   		.attr("font-size", "10")
															   		.attr("font-weight", "300")
															   		.attr("text-anchor", "middle")
															   		.attr("fill", "DarkSalmon");

															   	d3.select(".nodesLabel")
									      							.append("text")
									      							.attr("class", "temporary")
									      							.text(`${link.target.name.match(/\w/)}`)
									      							.attr("x", (link.target.x0+link.target.x1)/2)
															      	.attr("y", (link.target.y0+link.target.y1)/2 +2)
															   		.attr("font-size", "10")
															   		.attr("font-weight", "300")
															   		.attr("text-anchor", "middle")
															   		.attr("fill", "Tomato");

															   	// generating the Tooltip only for the link that's been mourseover-ed!
															   	// d3.select(".links")  // if I use this instead of sankeyChart, then labels will be hidden under nodes.
															   	sankeyChart.append("g")
																		   	.attr("class", "linkTooltip")
																		   	.append("text")
																			.text(`${link.value}`)   // ${link.source.name} â ${link.target.name}\n // here since I'm not binding any data, and I'm actually using the data bind to the event which is node data, there's no need for the usual style of d => `${d.source.name} â ${d.target.name}\n${d.value}`
																			.attr("x", (link.source.x0+link.target.x0)/2 + ((sankeyWidth/(L+1))/6) + margin.left)
																	      	.attr("y", (link.y0+link.y1)/2-12 + margin.top + deltaAxis)
																	   		.attr("font-size", 12)
																	   		.attr("font-weight", "300")
																	   		.attr("text-anchor", "middle")
																	   		.attr("fill", "Tomato");


															})
							    .on("mouseout", function(event, link) { 

							    								d3.select(".links")
							    									.selectAll("path")
							    									.attr("stroke", "DarkSeaGreen")
															   		.attr("stroke-opacity", p => opacityScale(p.value));

														    	

														    	d3.select(".nodes")
																	.selectAll("rect")
																	.attr("fill", "white");

																d3.selectAll(".temporary")
																	.remove();
																// d3.select(".temporary")
																// 	.remove();

																d3.select(".linkTooltip")
																	.remove();

														
														    })
							   .on("click", function(event, link) { 
							    							node1 = link.source;
													    	node2 = link.target;

													    	permissionLink = true; //when permissionLink is true, it means a link has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
															var prevFilteredData = nextFilteredData;
								      						nextFilteredData = Array.from(d3.intersection(filterbyNL(inputData,node1,prevFilteredData),filterbyNL(inputData,node2,prevFilteredData)));  // I had to add Array.from here, comparing to click on node. to have nextFilteredData is an array format. I could not figure out why the results are different when I click on node or link. anyway it's OK now :) even when nextFilteredData is a Set, the code & function works. the only problem is when you want to download the word list. !!!!!!!!!!!!!!!!!!!!
								      						sankeyChart.select(".nodes").remove();
								      						sankeyChart.select(".links").remove();
								      						d3.select(".nodesLabel").remove();
								      						d3.select(".axis").remove();
								      						d3.select(".linkTooltip").remove();


								      						d3.select("#output")
								      							.select("span")
								      							.text(nextFilteredData.length);

								      						generateSankey(nextFilteredData, permissionLink); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
								      						drawSankey(nextFilteredData, permissionLink); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
								      						
								      						console.log("words on link click", words);
								      						console.log("data on link click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
								      						console.log("prevFilteredData on link click", prevFilteredData); //OK
															console.log("nextFilteredData on link click", nextFilteredData); //OK

															wordList(nextFilteredData);

															
													    });
								
								
					// Nodes (after Links to have them on top of Links)
					sankeyChart.append("g")
								.attr("class", "nodes")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
						    	.selectAll("rect")
						    	.data(nodes) //here since nodes with value=0 has been filtered at generateSankey , instead of using data.nodes, use nodes & get rid of such a condition at each step of drawing nodes : d => (d.value!=0) ? d.x0 : 100)
						    	.join("rect")
						     	.attr("x", d => d.x0)
						      	.attr("y", d => d.y0)
						      	.attr("height", d => (d.y1 - d.y0))
						      	.attr("width", d => (d.x1 - d.x0))
						      	.attr("fill", "white")
						      	.attr("stroke", "navy")
						      	.on("mouseover", function(event, node) {
						      						// move the highlighted adjacent links to front:

						      						linkPaths = d3.select(".links")
				      												.selectAll("path")
				      												.nodes();

				      								linkHighlights = d3.filter(linkPaths, path => ((path.__data__.source.name == node.name) || (path.__data__.target.name == node.name)));
				      								// console.log("linkHighlights", linkHighlights); //OK

				      								d3.map(linkHighlights, path => moveToFront(path));


										      		// nodeData = this.__data__; no need to theis because node itself as the second input of a function applied on an event is the data :)
						      						d3.select(this) //"this" is each <rect>
						      							.attr("fill", "navy")
						      						d3.select(".nodesLabel")
						      							.append("text")
						      							.attr("class", "temporary")
						      							.text(`${node.name.match(/\w/)}`)
						      							.attr("x", (node.x0+node.x1)/2)
												      	.attr("y", (node.y0+node.y1)/2 +2)
												   		.attr("font-size", "10")
												   		.attr("font-weight", "300")
												   		.attr("text-anchor", "middle")
												   		.attr("fill", "DarkSalmon");
						      						
						      						highlightAdjLinks(node); //node as the second input of a function applied on an event is directly the bind data itself.
						      						

						      						

										      	})
						      	.on("mouseout", function(event, node){
						      						d3.select(this)
						      							.attr("fill", "white");

						      						d3.select(".temporary")
														.remove();

													unhighlightAdjLinks(node);
						      									
										      	})
						      	.on("click", function (event, node) {
						      						permissionNode = true; //when permissionNode is true, it means a node has been clicked. so nextFilteredData will NOT be reset to "wrods" each time the drawSankey is called to draw an updated diagram based on the most recent inputData :)
													var prevFilteredData = nextFilteredData;
						      						nextFilteredData = filterbyNL(inputData,node,prevFilteredData);
						      						sankeyChart.select(".nodes").remove();
						      						sankeyChart.select(".links").remove();
						      						d3.select(".nodesLabel").remove();
						      						d3.select(".axis").remove();



						      						d3.select("#output")
						      							.select("span")
						      							.text(nextFilteredData.length);

						      						generateSankey(nextFilteredData,permissionNode); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
						      						drawSankey(nextFilteredData, permissionNode); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.
						      						
						      						console.log("words on node click", words);
						      						console.log("data on node click", data); //OK Not only at this functions scope, but also in global scope "data" is affected when generateSankey & inside it prepareData functions are called at each click.
						      						console.log("prevFilteredData on node click", prevFilteredData); //OK
													console.log("nextFilteredData on node click", nextFilteredData); //OK
						      						highlightAdjLinks(node);

						      						wordList(nextFilteredData);

						      						
												      	});
						    	

					// Node Labels
			    	sankeyChart.append("g")
						    	.attr("class", "nodesLabel")
								.attr("transform", "translate(" + margin.left + "," + (margin.top + deltaAxis) + ")")
								.selectAll("text")
								.data(nodes)
								.join("text")
								.text(d => (d.value != 0) ? `${d.name.match((/\w/))}`: "")  
								.attr("x", d => d.x0+((sankeyWidth/(L+1))/6)) // x0 + nodeWidth/2
						      	.attr("y", d => (d.y0+d.y1)/2 +2) // +2 comes from this : lineheight(set equal to 1.2*fontsize at the * {} in style.css) - labelfontsize = 12 - 10 = 2 :)
						   		.attr("font-size", "10")
						   		.attr("font-weight", "300")
						   		.attr("text-anchor", "middle")
						   		.attr("fill", "navy");

					
				
					// Scale
					console.log("firstNode", nodes[0]); //OK
					console.log("lastNode", nodes[nodes.length-1]); //OK

					range = [(nodes[0].x0 + nodes[0].x1)/2  , (nodes[nodes.length-1].x0+nodes[nodes.length-1].x1)/2];
					// console.log("range", range); //OK
					positionScale = d3.scaleLinear()
										.domain([1, L]) // which is L = d3.max(inputData, w => w.length])
									  	.range(range);

					
					// Axis my style
					positionAxis = d3.axisBottom(positionScale)
										// explicitly determining tick values & determining their format with 1 digit precision, prevents the problem of encountering ticks like 1.5 (which is meaningless for a position of a letter!) when L is small.
										.tickValues([...Array(L+1).keys()].slice(1,L+1))
										.tickFormat(d3.format("0.2"))
										.tickSizeOuter(0)
										.tickSizeInner(0)
										.tickPadding(0);

					sankeyChart.append("g")
								.attr("class", "axis")
								.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
								.call(positionAxis)
								.attr("font-family", "hatch")
								.attr("font-size", "12")
								.attr("font-weight", "400")
								.attr("color", "navy")
								.select("path")
								.attr("stroke-opacity", 0);


					sankeyChart.select(".axis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", (range[0]+range[1])/2)
						        .attr("y", -15)
						        .attr("fill", "navy")
						        .attr("font-size", "12")
						        .attr("font-weight", "400")
						        .attr("text-anchor", "middle")
						        .text("LETTER INDEX");


				};


				// when click on white empty space, all links & node labels de-highlighted & 
				graphics.on("click",  function(event, element) {
											d3.select(".links")
												.selectAll("path")
												.attr("stroke-opacity", d => opacityScale(d.value))
												.attr("stroke", "DarkSeaGreen");

											d3.selectAll(".temporary")
												.remove();

										});
							


				
				// console.log("data in global scope", data); //OK
				drawSankey(mainWords);


/////////// Draw Histogram

				////////////////////////////////////////// 
				////////////////////////////////////////// 
				// if you want to have a smaller chart with zoom=100% & no side effects like decrease/increase of font-size., play with "660" & "width" in the following two lines of code. & in the css style you should set grid.area for .histogram accordingly. NO NEED to touch anything else in the code. :)  *better to have a graph a bit smaller than the grid area just to make sure it's always 100% :)
				// var histoHeight = 660 - margin.top - margin.bottom;  
				// var histoWidth = width - margin.left - margin.right;
				//////////////////////////////////////////
				//////////////////////////////////////////
				var histoHeight = 660/1.5 - margin.top - margin.bottom;
				var histoWidth = d3.select(".sankey").node().getBBox().width /3 - margin.left - margin.right; // & set grid-area to half of the total coloum
				

				const histoChart = graphics.append("svg")
											.classed("histogram", true)
											.attr("viewBox", [0, 0, histoWidth + margin.left + margin.right, histoHeight + margin.top + margin.bottom ]);

				function drawHisto(inputData) {

					bins = histo(inputData);
					console.log("bins", bins); //OK

					// Scales for smaller chart

					xScaleHisto = d3.scaleLinear()
								.domain([bins[0].x0, bins[bins.length-1].x1]) // -1  are to extend axis and add an extra tick just for appearance purpose. I will clear it later.  reasom :  x0 of the buckets are related to data domain. but not exactly. because when generating bins .thresholds(L) does not gaurantee to get L buckets!!! 
						   		.range([0, histoWidth]);
			   		// console.log("xScaleHisto domain", xScaleHisto.domain()); //OK

					yScaleHisto = d3.scaleLinear()
							    .domain([0, d3.max(bins, bucket => bucket.length)]).nice()
							    .range([histoHeight, 0]);
					

					histoChart.append("g")
								.attr("class", "histoRect")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.selectAll("rect")
								.data(bins)
								.join("rect")
						   		.attr("x", d => xScaleHisto(d.x0)) // -(xScaleHisto(b.x1)-xScaleHisto(b.x0))/2 is to center the rect on tick.
								.attr("width", d => Math.max(0, xScaleHisto(d.x1) - xScaleHisto(d.x0)-5)) // -5 just to add 5 pixel of white space btw rect elements
								.attr("y", d => yScaleHisto(d.length))
								.attr("height", d => yScaleHisto(0) - yScaleHisto(d.length))
								.attr("fill", (d, i) => d3.interpolateDiscrete(colours)(i/L), bins.length) //d3.piecewise(d3.interpolateRgb.gamma(2.2), ["CornflowerBlue", "Tomato", "CornflowerBlue"])(i/L)) //d3.interpolateHsl("CornflowerBlue", "Tomato")(i/L)) // d3.interpolateRainbow(i / L)); // d3.interpolateDiscrete(histoColours)(i), bins.length) this one is not working!!!

					rectWidth = d3.select(".histoRect").select("rect").node().getAttribute("width");

					histoChart.append("g")
							    	.attr("class", "histoLabel")
									.attr("transform", "translate(" + margin.left + "," + margin.top  + ")")
									.selectAll("text")
									.data(bins)
									.join("text")
									.text(d => d.length)  
									.attr("x", d => xScaleHisto(d.x0)+rectWidth/2)
							      	.attr("y", d => yScaleHisto(d.length)-10)
							   		.attr("font-size", "12")
							   		.attr("font-weight", "400")
							   		.attr("text-anchor", "middle")
							   		.attr("fill", "CornflowerBlue");
					
					// Axis my style
					L = d3.max(inputData, w => w.length);
					xAxisHisto = d3.axisBottom(xScaleHisto)
									.tickValues([...Array(L+1).keys()].slice(1,L+1))
									.tickSizeOuter(0)
									.tickSizeInner(0)
									.tickPadding(8)
									.tickFormat(d3.format("0.2"))
									// .ticks(L)
									

					histoChart.append("g")
								.attr("class", "xAxis")
								.attr("transform", `translate(${margin.left+rectWidth/2}, ${histoHeight+margin.top})`)
								.call(xAxisHisto)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "300")
								.attr("color", "grey");

					// clear those extra tick (first & last)  // it should be right after drawing axis. if later than that, the last of type wont be the last tick!!!!!!!!!
					
					histoChart.select(".xAxis")
								.selectAll(".tick:first-of-type text")
								.remove();
					// the following is required when xScaleHisto = d3.scaleLinear().domain([bins[0].x0-1, bins[bins.length-1].x1+1])	 // to remove that extra +1 tick at the end. other wise do not use this part:	
					// histoChart.select(".xAxis")
					// 			.selectAll(".tick:last-of-type text")
					// 			.remove();

					histoChart.select(".xAxis")
								.select("path")
								.remove();

					histoChart.select(".xAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", xScaleHisto.range()[1]-rectWidth/2)
						        .attr("y", margin.bottom/2+12)
						        .attr("fill", "grey")
						        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
						        .attr("font-weight", "300")
						        .attr("text-anchor", "end")
						        .text("LENGTH");



					yAxisHisto = d3.axisLeft(yScaleHisto)
									.tickSizeOuter(0)
									.tickSizeInner(0)
									.ticks(0);

					histoChart.append("g")
								.attr("class", "yAxis")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.call(yAxisHisto)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "300")
								.attr("color", "grey")
								.select("path")
								.attr("stroke-opacity", 0.5);;

					histoChart.select(".yAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", 0)
						        .attr("y", yScaleHisto.range()[1]-10) //yScaleHisto.range()[1]-margin.top+12
						        .attr("fill", "grey")
						        .attr("font-size", "10")
						        .attr("font-weight", "300")
						        .attr("text-anchor", "middle")
						        .text("WORD")
						        .text("COUNT");

				};


				drawHisto(mainWords);



/////////// Draw HeatMap
				var heatMapHeight = histoHeight; // = 660/1.5 - margin.top - margin.bottom; 
				var heatMapWidth = heatMapHeight;
				

				const heatmapChart = graphics.append("svg")
											.classed("heatmap", true)
											.attr("viewBox", [0, 0, heatMapWidth + margin.left + margin.right, heatMapHeight + margin.top + margin.bottom ]);
							
			

				function drawHeatMap(inputData) {

					heatmapData = heatmapInfo(inputData);

					config = {
							  paddingInner: 0,
							  paddingOuter: 0,
							  round: false, //rounding step to the closest integer
							  align: 0.5, //the ratio paddingOuter*2 will be devided btw left & right outer paddings.
							};

					xAlphabetScale = d3.scaleBand()
										.domain(d3.map(heatmapData, d => d[0][1]).sort(d3.ascending)) //alphabet)
									  	.range([0, heatMapWidth])
									 	.paddingInner(config.paddingInner)
									  	.paddingOuter(config.paddingOuter)
									  	.align(config.align)
									  	.round(config.round);

					yAlphabetScale = d3.scaleBand()
										.domain(d3.map(heatmapData, d => d[0][0]).sort(d3.descending)) //alphabet)
									  	.range([heatMapWidth, 0])
									 	.paddingInner(config.paddingInner)
									  	.paddingOuter(config.paddingOuter)
									  	.align(config.align)
									  	.round(config.round);

					// console.log("xAlphabetScale domain", xAlphabetScale.domain()); //OK
					// console.log("xAlphabetScale bandwidth", xAlphabetScale.bandwidth()); //OK
					// console.log("yAlphabetScale domain", yAlphabetScale.domain()); //OK
					// console.log("yAlphabetScale bandwidth", yAlphabetScale.bandwidth()); //OK

					colourScale = d3.scaleLinear()
									.domain(d3.extent(heatmapData, info => info[1].length))
									.range(["#f2eded", "Tomato"]);
					// console.log("colourScale domain", colourScale.domain()); //OK

					// Rects
					heatmapChart.append("g")
								.attr("class", "heatmapRects")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.selectAll("rect")
								.data(heatmapData)
								.join("rect")
						   		.attr("x", d => xAlphabetScale(d[0][1]))
								.attr("width", xAlphabetScale.bandwidth())
								.attr("y", d => yAlphabetScale(d[0][0]))
								.attr("height", yAlphabetScale.bandwidth())
								.attr("fill", d => colourScale(d[1].length))
								.attr("stroke", "none")
								.attr("opacity", 1)
								.on("mouseover", function(event, d) {
																// console.log("d",d,"this",this); //OK. d is data bind to rect. this is <rect>. 
																d3.select(".tooltip")
																	.selectAll("text")
																	.attr("font-size", t => (t[0] == d[0]) ? 12 : 0)
																	.attr("opacity",  t => (t[0] == d[0]) ? 1 : 0); // t is data bind to text.
																	// .attr("transform", `translate(${margin.left}, ${margin.top})`); // no need to transfer just THE required tip. when I used fontsize = 0 :)

																d3.select(this)
																	.attr("fill", "CornflowerBlue"); //.attr("stroke", "FireBrick"); this does not look nice because of crispEdges.
																	


								})
								.on("mouseout", function(event, d) {
																d3.select(".tooltip")
																	.selectAll("text")
																	// .attr("transform", (this.getAttribute("opacity") == 1) ? `translate(-${margin.left}, -${margin.top})` : "") // no need to transfer back  THE shown tip. when I used fontsize = 0 :)
															   		.attr("font-size", 0)
																	.attr("opacity", 0);

																d3.select(this)
																	.attr("fill" , d => colourScale(d[1].length));	//.attr("stroke", "none");

								})
								.on("click", function(event, d) {
															keyData = d[1];
															if (d[1].length <= 100) { 
																keyWords(keyData); 
															} else {
																d3.select(".keyWords").remove();
															};
															
								});
					
					// Tooltips
					heatmapChart.append("g")
								.attr("class", "tooltip")
								.attr("transform", `translate(${margin.left}, ${margin.top - yAlphabetScale.bandwidth()/2})`)
								.selectAll("text")
								.data(heatmapData)
								.join("text")
								.text(d => `${d[1].length} [ ${d[0][0]} ][ ${d[0][1]} ]`)  // (d[1].length == 1) ? `only ${d[1].length} word starts with ${d[0][0].toUpperCase()} and ends in ${d[0][1].toUpperCase()}` : `${d[1].length} words start with ${d[0][0].toUpperCase()} and end in ${d[0][1].toUpperCase()}`)   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?????????????????????
								.attr("x", d => xAlphabetScale(d[0][1]))
						      	.attr("y", d => yAlphabetScale(d[0][0]))
						   		.attr("font-size", 0) //deliberately fontsize=0. to have a 0x0 .tooltip. so it won't cover up the rects preventing mouseover on them!!!!!!!
						   		.attr("font-weight", "300")
						   		.attr("text-anchor", "start")
						   		.attr("fill", "DarkSlateGray")
						   		.attr("opacity", 0);
								

					
								

					// Axis my style
					xAxisHeatMap = d3.axisBottom(xAlphabetScale)
										.tickValues(xAlphabetScale.domain())
										.tickSizeInner(0)
										.tickSizeOuter(0)
										.tickPadding(8) // 8 = 2/3*12(leading)

									

					heatmapChart.append("g")
								.attr("class", "xAxis")
								.attr("transform", `translate(${margin.left}, ${heatMapHeight+margin.top})`)
								.call(xAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey");

					heatmapChart.select(".xAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", xAlphabetScale.range()[1])
						        .attr("y", margin.bottom/2+12) // 12 = the leading for fontsize 10. (1.2*10=12)
						        .attr("fill", "grey")
						        .attr("font-size", "10") // if you want to set font size related to margin :)) `${margin.right/6}`
						        .attr("font-weight", "300")
						        .attr("text-anchor", "end")
						        .text("LAST LETTER");


			        yAxisHeatMap = d3.axisLeft(yAlphabetScale)
							.tickValues(yAlphabetScale.domain())
							.tickSizeInner(0)
							.tickSizeOuter(0)
							.tickPadding(8);

					heatmapChart.append("g")
								.attr("class", "yAxis")
								.attr("transform", `translate(${margin.left}, ${margin.top})`)
								.call(yAxisHeatMap)
								.attr("font-family", "hatch")
								.attr("font-size", "10")
								.attr("font-weight", "400")
								.attr("color", "grey")
								.select("path")
								.attr("stroke-opacity", 0.5);;

					heatmapChart.select(".yAxis")
								.append("g")
								.attr("class", "axisLabel")
								.append("text")
						        .attr("x", 0)
						        .attr("y", yAlphabetScale.range()[1]-10)
						        .attr("fill", "grey")
						        .attr("font-size", "10")
						        .attr("font-weight", "300")
						        .attr("text-anchor", "middle")
						        .text("WORD")
						        .text("FIRST LETTER");

					
					heatmapChart.select(".xAxis")
								.selectAll(".tick")
								.select("text")
								.on("click", function(event, d) {
												keyData = endLetter(inputData, d);
												keyWords(keyData);
								});
					heatmapChart.select(".yAxis")
								.selectAll(".tick")
								.select("text")
								.on("click", function(event, d) {
												keyData = startLetter(inputData, d);
												keyWords(keyData);
								})
					
				};
				
				drawHeatMap(mainWords);


/////////// Draw Flower

				const flowerChart = flower.append("svg")
										.classed("flower", true)
										.attr("viewBox", [0, 0, flowerWidth + margin.left + margin.right , flowerHeight + margin.top + margin.bottom]);
				
				
				function drawFlower(inputData, permission) {
					words = filterbyLength(inputData, d3.max(inputData, w => w.length));
					generateFlower(words, permission);
					
					if (!permission) { nextFilteredData = words;} else {nextFilteredData = nextFilteredData;} ;

					// console.log("valueExtent", d3.extent(flowerValues, g => g[1])); //OK


					flowerScale = d3.scaleLinear()
									.domain(d3.extent(links, l => l.value))
									.range(["LightSeaGreen", "SeaGreen"]);

					strokeScale = d3.scaleLinear()
									.domain(d3.extent(links, l => l.value))
									.range([0.3, 1]);

					letterScale = d3.scaleOrdinal()
									.domain(alphabet)
									.range(colours);


					
					// Links
				    flowerChart.append("g")
							    .attr("class", "flowerLinks")
								.attr("transform", "translate(" + (margin.left + flowerWidth/2) + "," + (margin.top + flowerWidth/2) + ")")
							    .selectAll("path")
							    .data(links)
							    .join("path")
							    .attr("d", flowerLinkGenerator)
							    .attr("fill", "none")
							    .attr("stroke", d => flowerScale(d.value))
							    .attr("stroke-width", d => strokeScale(d.value))
							    .attr("stroke-opacity", 0.3)
								.append("title")
							    .text(d => `${d.source.key} â ${d.target.key} \n ${d.value}`);

					// Nodes
					flowerChart.append("g")
								.attr("class", "flowerNodes")
								.attr("transform", "translate(" + (margin.left + flowerWidth/2) + "," + (margin.top + flowerWidth/2) + ")")
						    	.selectAll("circle")
						    	.data(nodes)
						    	.join("circle")
						     	.attr("cx", d => d.cx)
						      	.attr("cy", d => d.cy)
						      	.attr("r", d => Math.max(3,r))
						      	.attr("fill", d => letterScale(d.key)) //d3.interpolateDiscrete(colours)(((alphabet.indexOf(d.key.match(/\w/)))%26)/26),26)
						    	.append("title")
						    	.text(d => `${d.key}\n${d.code}`);

				};

				drawFlower(mainWords);


				// click to zoom on flower !!!!


				function dragstarted(event, d) {
				    d3.select(this).raise();
				    d3.select(".flowerNodes").attr("cursor", "grabbing");
				};

				function dragged(event, d) {

					d3.select(".flowerLinks")
						.selectAll("path")
						.attr("transform", p => (d.code == p.source.code) ? "translate(" + event.x + "," + event.y + ")" : "translate(" + 0 + "," + 0 + ")");

					d3.select(".flowerNodes")
						.selectAll("circle")
						.attr("transform", c => (d.code == c.code) ? "translate(" + event.x + "," + event.y + ")" : "translate(" + 0 + "," + 0 + ")");

				    // d3.select(this).attr("cx", d.cx = event.x).attr("cy", d.cy = event.y);

				    // also move the link or whole word???????!!!!
				};

				function dragended(event, d) {
				    d3.select(".flowerNodes").attr("cursor", "grab");
				};

				drag = d3.drag()
				          .on("start", dragstarted)
				          .on("drag", dragged)
				          .on("end", dragended);

				//drag is applied on each node
				d3.select(".flowerNodes")
					.selectAll("circle")
					.call(drag);

				// zoom is applied on the SVG element
				function zoomed(event) {
					// console.log("zoom event", event); //OK
				    const t = event.transform;
				    const k = t.k; // scale factor
				    const x = t.x; // deltaX
				    const y = t.y; // deltaY
				    // d3.select(this).attr("transform", t); // equal to : d3.select(this).attr("transform", "translate(" + x + "," + y + " )scale(" + k + ")");
				    // if you want to cancel the effect of x & y transfer, you can use the following line: 
				    d3.select(this).attr("transform", "translate(" + 0 + " )scale(" + k + ")");
				};


				flowerZoom = d3.zoom()
							    .scaleExtent([0.25, 4])
							    .translateExtent([[0, 0], [flowerWidth, flowerHeight]])
							    .on("zoom", zoomed);



				flowerChart.call(flowerZoom)
							.call(flowerZoom.transform, d3.zoomIdentity
															.scale(1.2));


				// flowerChart.call(flowerZoom.scaleBy, 3) // instantly scales it up to 3 :))
				  

				// flowerChart.on("click", function(event, svg) {

				// 	flowerChart.transition()
				// 			.call(flowerZoom.translateBy, flowerWidth/2, flowerHeight/2)

				// 	flowerChart.call(flowerZoom.scaleBy, 3)
				// 				.call(flowerZoom.transform, d3.zoomIdentity
				// 											.translate(margin.left, margin.top));
				// });

				  


/////////// Toolbar

			

				// Slider change
				function sliderUpdate(lengthLimit) {

					d3.select("#wordLength")
						.node()
						.setAttribute("value", lengthLimit);

       				// d3.select("#wordLength")
						// .clone();
						
					// d3.select("#wordLength")
					// 	.remove();


					d3.select("#slider")
						.select("span")
						.text(lengthLimit);

					
					sankeyChart.select(".nodes").remove();
					sankeyChart.select(".links").remove();
					d3.select(".nodesLabel").remove();
					d3.select(".axis").remove();
					d3.select(".words").remove();
					d3.select(".keyWords").remove();
					

					words = filterbyLength(mainWords, lengthLimit);
					console.log("words on slider change", words);
					generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
					drawSankey(words, false); //the problem is that nextFilteredData is set to words each time sankeyDraw is called.


					d3.select("#output")
						.select("span")
						.text(words.length);
				};

				d3.select("#wordLength")
					.on("click", function() {
											lengthLimit = this.value;
											sliderUpdate(lengthLimit);
										});



				//Buttons

				d3.select("#reset")
					.select(".button")
					.on("click", function() {

										lengthLimit = d3.max(mainWords, w => w.length);
										sliderUpdate(lengthLimit);

										sankeyChart.select(".nodes").remove();
			      						sankeyChart.select(".links").remove();
										d3.select(".nodesLabel").remove();
										d3.select(".axis").remove();
										d3.select(".words").remove();
										d3.select(".keyWords").remove();

										words = filterbyLength(mainWords, d3.max(mainWords, w => w.length));
			      						generateSankey(words, false); // "data" in global scope is affected when generateSankey & inside it prepareData functions are called at each click.
			      						drawSankey(words, false);
			      						// set slider intial value to max length of the whole dataset
										// permissionNode=false;
										// permissionLink=false;


									});


				d3.select("#list")
					.select(".button")
					.on("click", function() {
									// console.log("nextFilteredData in download scope", nextFilteredData); //OK
									conent = nextFilteredData;
									header = "data:text/plain;charset=utf-8,"
									payload = header + encodeURIComponent(conent);

									this.href = payload;
								});



				






			  // alert("done");
			
			



							



			

			}); // this is the END of .then(function(rawdata) {...  after loading data :)


		</script>
		

	</body>
</html>